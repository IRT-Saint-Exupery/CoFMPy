{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#about-cofmupy","title":"\ud83d\udc4b About CoFmuPy","text":"<p>CoFmuPy is a Python library designed for rapid prototyping of digital twins through the co-simulation of Functional Mock-up Units (FMUs). It offers advanced master coordination features, such as solving algebraic loops between FMUs and managing the interaction between various simulation components. This library provides a seamless interface to orchestrate complex physics simulations and handle the data exchange between FMUs.</p> <p>The documentation is available online: https://irt-saint-exupery.github.io/CoFmuPy</p>"},{"location":"#installation","title":"\ud83d\udc3e Installation","text":"<p>CoFmuPy is available on PyPI and can be installed using <code>pip</code>:</p> <pre><code>pip install cofmupy\n</code></pre>"},{"location":"#key-keatures","title":"\ud83d\udc0d Key Keatures","text":"<p>CoFmuPy provides a Python interface (with a graphical user interface under development) for configuring and running co-simulations of FMI-based systems, with a focus on coordinating interacting FMUs within complex digital twin architectures.</p> <p>A high-level API allows users to easily define, execute, and visualize digital twins scenarios, while still enabling more advanced control when needed.</p> <p>Building on the FMPy library as an FMI-compliant execution backend, CoFmuPy focuses on system-level co-simulation capabilities and advanced coordination logic. In particular, CoFmuPy provides the following key features:</p> <ul> <li> <p>Advanced master coordination for coupled FMUs: Native master algorithms orchestrate the execution of multiple interacting FMUs, ensuring coherent time advancement and stable system-level simulation across heterogeneous subsystems. Cyclic dependencies between FMUs (algebraic loops) are automatically detected and resolved using fixed-point strategies, supporting both Jacobi and Gauss\u2013Seidel co-simulation schemes, with or without rollback. This enables the simulation of tightly coupled systems without manual intervention or model restructuring.</p> </li> <li> <p>Explicit data exchange and synchronization mechanisms: CoFmuPy provides fine-grained control over data routing, synchronization, and signal propagation between FMUs, as well as between FMUs and external data sources or sinks.</p> </li> <li> <p>Native integration of Python and AI components: Python-based models (e.g., machine learning or control logic) can be directly integrated into the co-simulation loop without immediate FMU export while still being FMI-compliant, enabling full integration of AI frameworks.</p> </li> <li> <p>Declarative and reproducible configuration: Co-simulation systems are fully defined through a structured JSON configuration file, making experiments easy to reproduce, modify, and extend.</p> </li> <li> <p>Graphical interface (coming soon): A user-friendly graphical interface will enable drag-and-drop system construction, FMU interconnection, remote interfaces configuration, algorithm selection, and co-simulation control.</p> </li> </ul>"},{"location":"#json-configuration-file","title":"\ud83d\udcdc JSON configuration file","text":"<p>To properly define the co-simulation system, a JSON configuration file must be created. This file is the only information required by CoFmuPy to run the simulation. It must respect a specific syntax in order to define the FMUs, the interactions between them, the data sources and sinks, etc.</p>"},{"location":"#citation","title":"\ud83d\udcda Citation","text":"<p>If you use CoFmuPy in your research or publications, please cite:</p> <pre><code>@inproceedings{friedrich2025cofmupy,\n  title={CoFmuPy: A Python Framework for Rapid Prototyping of FMI-based Digital Twins},\n  author={Friedrich, Corentin and Lombana, Andr{\\'e}s and Fasquel, J{\\'e}r{\\^o}me and Schlick, Charlie and Bennani, Nora and Mendil, Mouhcine},\n  booktitle={The 2nd International Conference on Engineering Digital Twins},\n  year={2025}\n}\n</code></pre>"},{"location":"#contributing","title":"\u2712\ufe0f Contributing","text":"<p>Feel free to propose your ideas or come and contribute with us on the CoFmuPy library!</p>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>This project was funded by the European Union under GA no 101101961 - HECATE. Views and opinions expressed are however those of the authors only and do not necessarily reflect those of the European Union or Clean Aviation Joint Undertaking. Neither the European Union nor the granting authority can be held responsible for them. The project is supported by the Clean Aviation Joint Undertaking and its Members.</p>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>The package is released under the 2-Clause BSD License.</p>"},{"location":"contributing/","title":"\u2712\ufe0f Contributing to CoFmuPy","text":"<p>First off, thank you for considering contributing to CoFmuPy! By contributing, you help improve this project and make it available to many others. We welcome contributions in various forms, whether it\u2019s through code, documentation, bug reports, or feature suggestions.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<p>We appreciate all kinds of contributions. Whether you find bugs, want to improve documentation, or implement new features, there are several ways you can contribute.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug or unexpected behavior, please follow these steps: 1. Search the existing issues to check if it has already been reported. 2. If it's a new issue, create a new issue with the following information:    - A clear description of the problem.    - Steps to reproduce the issue (if possible).    - Your environment details (e.g., operating system, Python version).    - Error messages or logs, if any.</p>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>We love hearing about new ideas for features or improvements! To suggest a feature: 1. Search to see if someone else has already suggested it. 2. If it's not already suggested, create a new issue to describe the enhancement:    - A clear explanation of the feature and its use cases.    - Why it would be valuable to the project.    - If applicable, any examples of how the feature might work.</p>"},{"location":"contributing/#submitting-code","title":"Submitting Code","text":"<p>We welcome code contributions! If you want to submit code, please follow the steps below.</p> <ol> <li>Fork the repository and clone your fork to your local machine. As some files are    stored with Git LFS, don't forget to install git-lfs with <code>git lfs install</code> and then    run <code>git lfs checkout</code> to retrieve the actual LFS files after cloning.</li> <li>Create a new branch for your changes. Try to name it meaningfully, such as    <code>fix/bug-description</code> or <code>feature/feature-name</code>.</li> <li>Make your changes. Ensure that your changes don't break the existing    functionality. Follow Pylint style guidelines.</li> <li>Write tests to cover your changes, if applicable. See the Testing    section for more details.</li> <li>Commit your changes with a descriptive commit message.</li> <li>Push your branch to your fork on GitHub.</li> <li>Open a Pull Request (PR) with a clear description of your changes.</li> </ol>"},{"location":"contributing/#setup-installation-for-developers","title":"Setup Installation for Developers","text":"<p>To get started with contributing to this project, you'll need to set up your development environment.</p> <ol> <li>Clone the repo: <code>git clone https://github.com/blabla/cofmupy.git</code></li> <li>Go to the root of the repo: <code>cd cofmupy</code></li> <li> <p>Create a new virtual environement:</p> <ul> <li>using <code>venv</code> on Linux:</li> </ul> <pre><code>python3 -m venv env_cofmupy\nsource env_cofmupy/bin/activate\n</code></pre> <ul> <li>using <code>venv</code> on Windows:</li> </ul> <pre><code>python3 -m venv env_cofmupy\nenv_cofmupy/Scripts/activate.bat\n</code></pre> <ul> <li>using <code>conda</code>:</li> </ul> <pre><code>conda create -n env_cofmupy python=3.10\nconda activate env_cofmupy\n</code></pre> </li> <li> <p>Install dependencies using <code>pip</code>:</p> </li> </ol> <pre><code>pip install -U pip\npip install -r requirements.txt -r requirements_dev.txt\npip install -e .\n</code></pre> <p>Your environment is now ready for development! You can run <code>pytest</code>\u00a0to verify that the environment is set up correctly.</p>"},{"location":"contributing/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Write clear, concise code that follows Python best practices.</li> <li>Ensure that your code is compatible with Python 3.9+.</li> <li>Document your code with docstrings, especially for functions, classes, and   modules.</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for your changes (if applicable). We use pytest for   testing, so please ensure your code passes the existing tests as well as any new ones.</li> <li>To run CI tests locally, use either:</li> <li><code>tox</code> environments, e.g. <code>tox -e py310-lint</code> for format/lint checks and <code>tox -e     py310</code> for pytest unit tests.</li> <li>or directly using <code>black</code>, <code>pylint</code> and <code>pytest</code>:</li> </ul> <pre><code>python -m black --check --diff\npython -m pylint cofmupy\npytest\n</code></pre>"},{"location":"contributing/#generating-documentation","title":"Generating Documentation","text":"<p>The documentation is generated with MkDocs. From the root of the repo, you can generate the documentation and run the live server with:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started with CoFmuPy","text":"<p>CoFmuPy is a framework designed to make co-simulation and prototyping digital twins easy and efficient. This guide walks you through setting up and running your first simulation with CoFmuPy!</p>"},{"location":"getting_started/#installation","title":"\ud83d\udc3e Installation","text":"<p>Before you begin, ensure CoFmuPy is installed:</p> <pre><code>pip install cofmupy\n</code></pre>"},{"location":"getting_started/#running-your-first-simulation","title":"\ud83d\udcbb Running Your First Simulation","text":"<p>With CoFmuPy, you can simulate complex systems composed of multiple FMUs connected together. You can even integrate external files or network interfaces. For now, we will keep it simple and consider the system consisting of an alternating voltage source and a resistor, as shown in the figure below:</p> <ul> <li>The source outputs a voltage signal, denoted as \\(V\\) (in Volts).</li> <li>The resistor takes \\(V\\) as input and produces an output current \\(I\\) (in Amperes). The resistance parameter \\(R\\) is set to \\(0.5 \\Omega\\).</li> </ul> <p>We've already prepared FMUs and configuration file associated to this scenario. Let's start by downloading them.</p> <pre><code>import os\nimport urllib.request\nimport zipfile\n\nurl = \"https://share-is.pf.irt-saintexupery.com/s/39zaG9HkQWnePbi/download\"\nresources_path = \"example1.zip\"\n\nurllib.request.urlretrieve(url, resources_path)\nwith zipfile.ZipFile(resources_path, \"r\") as zip_ref:\n    zip_ref.extractall(\".\")\nos.remove(resources_path)\n\nprint(\"Resources unzipped in example1 folder!\")\n</code></pre>"},{"location":"getting_started/#step-1-instantiate-the-coordinator","title":"Step 1: Instantiate the Coordinator","text":"<p>The heart of CoFmuPy is the <code>Coordinator</code>, which is responsible for managing the simulation process. We begin by instantiating it and loading the configuration file just downloaded above:</p> <pre><code># Import the main CoFmuPy component\nfrom cofmupy import Coordinator\n\n# Create an instance of the Coordinator\ncoordinator = Coordinator()\n\n# Load the simulation setup from a JSON configuration file\ncoordinator.start(\"example1/config.json\")\n</code></pre> <p>For a quick view of the JSON configuration file, take a look at our first tutorial.</p> <p>To make sure your simulation is correctly set up, you can visualize the connection graph of your system:</p> <pre><code># Display a graphical representation of the simulated system\ngraph = coordinator.graph_engine.plot_graph()\ngraph.show()\n</code></pre>"},{"location":"getting_started/#step-2-execute-a-simulation-step-or-run-it-until-completion","title":"Step 2: Execute a Simulation Step or run it until completion","text":"<p>Here, you can either execute the simulation step by step or run it until completion.</p> <pre><code># Define the time step for the simulation\nstep_size = 0.05\n\n# Run a single step of the simulation\ncoordinator.do_step(step_size)\n\n# Print the current time in the simulation\nprint(f\"Current simulation time: {coordinator.master.current_time}\")\n\n# Alternatively, run the co-simulation until a specified end time\nend_time = 0.5\ncoordinator.run_simulation(step_size, end_time)\nprint(\"Simulation completed!\")\n</code></pre>"},{"location":"getting_started/#step-3-access-results","title":"Step 3: Access Results","text":"<p>Once the simulation is finished, you can retrieve and inspect the results.</p> <pre><code># Retrieve stored simulation results\nresults = coordinator.get_results()\n\n# Display a preview of the results\nprint(results[(\"source\", \"V\")])\nprint(results[(\"resistor\", \"I\")])\n</code></pre>"},{"location":"getting_started/#whats-next","title":"\u23ed What\u2019s Next?","text":"<ul> <li>Try modifying the configuration file to explore different scenarios.</li> <li>Experiment with different step sizes to see how they affect results.</li> <li>Explore CoFmuPy's examples gallery.</li> <li>Dive deeper into advanced features by checking the official documentation.</li> </ul>"},{"location":"api/","title":"API documentation","text":"<p>This is the API documentation.</p>"},{"location":"api/#end-user-documentation","title":"End-user documentation","text":"<p>As an end user, we suggest to start with the main object in CoFmuPy: the Coordinator. After creating your JSON configuration file, the Coordinator is the only CoFmuPy object to start with: you can load the configuration file, run a co-simulation and plot results.</p>"},{"location":"api/#developer-documentation","title":"Developer documentation","text":"<p>As a developer, you may need to implement your own blocks, e.g. a custom data stream handler. In this case, you must follow the same interface as the objects already provided in CoFmuPy: inheritance, abstract methods and members, etc. For more details, take a look at the API documentation and the advanced user guide.</p>"},{"location":"api/config_parser/","title":"The Parser for Configuration File","text":"<p>This module is designed to parse, validate, and structure a JSON configuration file for the co-simulation framework. It ensures that all necessary configurations for GraphEngine, Master DataStreamHandlers, and DataStorages are correctly formatted and ready for execution. Additionally, it performs sanity checks to detect missing keys, redundant endpoints, and orphaned connections.</p>"},{"location":"api/config_parser/#cofmupy.config_parser.ConfigParser","title":"ConfigParser","text":"<pre><code>ConfigParser(file_path)\n</code></pre> <p>Parses and validates JSON configuration files.</p> <p>This class handles loading, validation, and transformation of configuration data for various components such as the Graph Engine, Master Solver, Data Storages, and Stream Handlers.</p> ATTRIBUTE DESCRIPTION <code>file_path</code> <p>Path to the configuration file. Can also be a dictionary if the user prefers to provide the configuration directly without using a JSON file.</p> <p> TYPE: <code>Union[str, Dict]</code> </p> <code>_config_object</code> <p>The parsed configuration object (type ConfigObject)</p> <p> TYPE: <code>ConfigObject</code> </p> <code>graph_config</code> <p>Configuration for the graph engine.</p> <p> TYPE: <code>Dict</code> </p> <code>master_config</code> <p>Configuration for the master solver.</p> <p> TYPE: <code>Dict</code> </p> <code>data_storages</code> <p>Storage settings for external data.</p> <p> TYPE: <code>Dict</code> </p> <code>stream_handlers</code> <p>Handlers for external data streams.</p> <p> TYPE: <code>Dict</code> </p> <code>error_in_config</code> <p>Indicates whether errors exist in the configuration.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>cofmupy/config_parser.py</code> <pre><code>def __init__(self, file_path: Union[str, Dict]) -&gt; None:\n    # Arguments\n    self.file_path = file_path\n\n    self._config_object: ConfigObject\n    self.graph_config: Dict = {}\n    self.master_config: Dict = {}\n    self.data_storages: Dict = {}\n    self.stream_handlers: Dict = {}\n    self.error_in_config: bool = False\n\n    # ------------ 1. Load config: self._config_object ------------------\n    self._config_object = self._load_config(file_check=True)\n\n    # ------------ 2. Apply defaults and perform validation ------------\n    self._validate_configuration()\n\n    # ------------ 3. Build configurations ---------------------------\n    self._build_storage_config()\n    self._build_master_config()\n    self._build_handlers_config()\n    self._build_graph_config()\n</code></pre>"},{"location":"api/config_parser/#cofmupy.config_parser.ConfigParser.config_dict","title":"config_dict  <code>property</code>","text":"<pre><code>config_dict\n</code></pre> <p>Construct and return dict from protected _config_object</p> RETURNS DESCRIPTION <code>config</code> <p>config formatted as a dict</p> <p> TYPE: <code>dict</code> </p>"},{"location":"api/config_parser/#cofmupy.config_parser.ConfigParser.fill_data_storage","title":"fill_data_storage","text":"<pre><code>fill_data_storage(targets, storage_id, storage_title)\n</code></pre> <p>Fill data storage with labels and items</p> Source code in <code>cofmupy/config_parser.py</code> <pre><code>def fill_data_storage(self, targets: list, storage_id: str, storage_title: str):\n    \"\"\"\n    Fill data storage with labels and items\n    \"\"\"\n    for target2 in targets:\n        if isinstance(target2, ConfigConnectionFmu):\n            self.data_storages[storage_id][\"config\"][\"labels\"].append(storage_title)\n            self.data_storages[storage_id][\"config\"][\"items\"].append(\n                (target2.id, target2.variable)\n            )\n</code></pre>"},{"location":"api/coordinator/","title":"Coordinator","text":"<p>The Coordinator is the main class in CoFmuPy. It controls the blocks internally in order to ease the usage of the library. For end users, this is the only interface to start with: from a JSON configuration file, the coordinator will instantiate and monitor all the required components.</p> <pre><code>from cofmupy import Coordinator\n\n# Instantiate the Coordinator\nmy_coordinator = Coordinator()\n\n# Start the Coordinator (and all its components) from a JSON configuration file\nmy_coordinator.start(conf_path=\"my_config_file.json\")\n</code></pre> <p>The Coordinator can then run the simulation using <code>do_step()</code> or <code>run_simulation()</code>. Internally, the Master component will execute the steps of the co-simulation.</p> <pre><code>n_steps = 100\nfor _ in range(N):\n    my_coordinator.do_step(step_size=0.05)\n</code></pre> <p>It is then possible to get the simulation results as a Pandas dataframe :</p> <pre><code>results_df = my_coordinator.get_results()\n</code></pre> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def __init__(self):\n    self.config_parser = None\n    self.graph_engine = None\n    self.master = None\n    self.stream_handlers = None\n    self.storage_handler: StorageHandler\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.do_step","title":"do_step","text":"<pre><code>do_step(step_size: float, save_data=False)\n</code></pre> <p>Perform a simulation step.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>simulation step size</p> <p> TYPE: <code>float</code> </p> <code>save_data</code> <p>whether to save the data in the default CSV data storage. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def do_step(self, step_size: float, save_data=False):\n    \"\"\"\n    Perform a simulation step.\n\n    Args:\n        step_size (float): simulation step size\n        save_data (bool): whether to save the data in the default CSV data storage.\n            Defaults to False.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    # Format: [{(fmu1, var1): value}, {(fmu2, var2): value, (fmu3, var3): value}]\n    data = [dh.get_data(self.master.current_time) for dh in self.stream_handlers]\n\n    # Format: {(fmu1, var1): value}, (fmu2, var2): value, (fmu3, var3): value}\n    data = {k: v for d in data for k, v in d.items()}\n\n    # Format: {fmu1: {var1: value1}, fmu2: {var2: value2}, fmu3: {var3: value3}}\n    data_for_master = defaultdict(dict)\n    for (fmu, var), val in data.items():\n        data_for_master[fmu][var] = [val]\n\n    # Do step in the master\n    outputs = self.master.do_step(step_size, input_dict=data_for_master)\n\n    # Save results and data\n    if save_data:\n        for input_key, input_value in data_for_master.items():\n            for variable_name, variable_value in input_value.items():\n                outputs[input_key][variable_name] = variable_value\n        self.storage_handler.notify_results(\n            \"file\", self.master.current_time, outputs\n        )\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.get_causality","title":"get_causality","text":"<pre><code>get_causality(name: tuple) -&gt; str\n</code></pre> <p>Gets the causality of the given variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>str</code> <p>causality of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def get_causality(self, name: tuple) -&gt; str:\n    \"\"\"\n    Gets the causality of the given variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        str: causality of the variable.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    return self.master.get_causality(name)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.get_results","title":"get_results","text":"<pre><code>get_results() -&gt; dict\n</code></pre> <p>Get the results from the simulation.</p> RETURNS DESCRIPTION <code>dict</code> <p>dataframe with the results.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def get_results(self) -&gt; dict:\n    \"\"\"\n    Get the results from the simulation.\n\n    Returns:\n        dict: dataframe with the results.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n    return self.master.get_results()\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: tuple) -&gt; list\n</code></pre> <p>Get the value of the given tuple fmu/variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>list</code> <p>value of the variable, as a list.</p> <p> TYPE: <code>list</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def get_variable(self, name: tuple) -&gt; list:\n    \"\"\"\n    Get the value of the given tuple fmu/variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        list: value of the variable, as a list.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    return self.master.get_variable(name)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.get_variable_names","title":"get_variable_names","text":"<pre><code>get_variable_names() -&gt; list\n</code></pre> <p>Get the names of all variables in the system.</p> RETURNS DESCRIPTION <code>list</code> <p>list of variable names as (fmu_id, var_name) tuples.</p> <p> TYPE: <code>list</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def get_variable_names(self) -&gt; list:\n    \"\"\"\n    Get the names of all variables in the system.\n\n    Returns:\n        list: list of variable names as (fmu_id, var_name) tuples.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n    return self.master.variable_names\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.get_variable_type","title":"get_variable_type","text":"<pre><code>get_variable_type(name: tuple) -&gt; str\n</code></pre> <p>Get the type of the given variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>str</code> <p>type of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def get_variable_type(self, name: tuple) -&gt; str:\n    \"\"\"\n    Get the type of the given variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        str: type of the variable.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    return self.master.get_variable_type(name)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.get_variables","title":"get_variables","text":"<pre><code>get_variables(names: list) -&gt; dict\n</code></pre> <p>Get the values of the given variables.</p> PARAMETER DESCRIPTION <code>names</code> <p>list of variable names as (fmu_id, var_name) to get, e.g. [(\"fmu1\", \"var3\"), (\"fmu2\", \"var1\")].</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>dictionary with the variable names and their values.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def get_variables(self, names: list) -&gt; dict:\n    \"\"\"\n    Get the values of the given variables.\n\n    Args:\n        names (list): list of variable names as (fmu_id, var_name) to get,\n            e.g. [(\"fmu1\", \"var3\"), (\"fmu2\", \"var1\")].\n\n    Returns:\n        dict: dictionary with the variable names and their values.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    var_values = {}\n    for name in names:\n        var_values[name] = self.get_variable(name)\n\n    return var_values\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.load_data_storages","title":"load_data_storages","text":"<pre><code>load_data_storages(data_storages_config: dict)\n</code></pre> <p>Load the data storages from the given dictionary of configurations.</p> PARAMETER DESCRIPTION <code>data_storages_config</code> <p>dictionary containing the configurations for the data storages.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def load_data_storages(self, data_storages_config: dict):\n    \"\"\"\n    Load the data storages from the given dictionary of configurations.\n\n    Args:\n        data_storages_config (dict): dictionary containing the configurations for\n            the data storages.\n    \"\"\"\n    for storage in data_storages_config.values():\n        self.storage_handler.register_storage(storage[\"type\"], storage[\"config\"])\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.load_stream_handlers","title":"load_stream_handlers","text":"<pre><code>load_stream_handlers(stream_handlers: dict)\n</code></pre> <p>Load the stream handlers from the given dictionary of configurations.</p> PARAMETER DESCRIPTION <code>stream_handlers</code> <p>dictionary containing the configurations for the stream handlers.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def load_stream_handlers(self, stream_handlers: dict):\n    \"\"\"\n    Load the stream handlers from the given dictionary of configurations.\n\n    Args:\n        stream_handlers (dict): dictionary containing the configurations for the\n            stream handlers.\n    \"\"\"\n\n    self.stream_handlers = []\n\n    for key, config in stream_handlers.items():\n        var_name = config[\"config\"].pop(\"variable\", \"\")\n        # Check if the stream handler already exists\n        for dh in self.stream_handlers:\n            if dh.is_equivalent_stream(**config[\"config\"]):\n                break\n        else:\n            # If not (i.e. break not executed), create a new stream handler\n            dh = BaseDataStreamHandler.create_handler(config)\n            self.stream_handlers.append(dh)\n\n        # Add variable to the stream handler for mapping\n        dh.add_variable(key, var_name)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.parse_config","title":"parse_config","text":"<pre><code>parse_config(config_path: str)\n</code></pre> <p>Start the configuration parser to parse the given configuration file.</p> PARAMETER DESCRIPTION <code>config_path</code> <p>path to the configuration file</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def parse_config(self, config_path: str):\n    \"\"\"\n    Start the configuration parser to parse the given configuration file.\n\n    Args:\n        config_path (str): path to the configuration file\n    \"\"\"\n\n    self.config_parser = ConfigParser(config_path)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.run_simulation","title":"run_simulation","text":"<pre><code>run_simulation(\n    step_size: float,\n    end_time: float,\n    save_data: bool = False,\n)\n</code></pre> <p>Run the simulation until the given end time.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>simulation step size</p> <p> TYPE: <code>float</code> </p> <code>end_time</code> <p>simulation end time</p> <p> TYPE: <code>float</code> </p> <code>save_data (boolean) </code> <p>whether to save data into configured storages or not</p> <p> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def run_simulation(\n    self, step_size: float, end_time: float, save_data: bool = False\n):\n    \"\"\"\n    Run the simulation until the given end time.\n\n    Args:\n        step_size (float): simulation step size\n        end_time (float): simulation end time\n        save_data (boolean) : whether to save data into configured storages or not\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    while self.master.current_time &lt; end_time:\n        self.do_step(step_size, save_data=save_data)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.save_results","title":"save_results","text":"<pre><code>save_results(filename: str)\n</code></pre> <p>Save the results to a CSV file.</p> PARAMETER DESCRIPTION <code>filename</code> <p>name of the CSV file to save the results to.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def save_results(self, filename: str):\n    \"\"\"\n    Save the results to a CSV file.\n\n    Args:\n        filename (str): name of the CSV file to save the results to.\n    \"\"\"\n    df_results = pd.DataFrame.from_dict(self.get_results())\n\n    # Sort the columns starting with \"time\" and then alphabetically\n    columns = df_results.columns.tolist()\n    columns.remove(\"time\")\n    columns = [\"time\"] + sorted(columns)\n\n    # Set headers of the CSV file where tuple (fmu, var_name) is replaced by\n    # \"fmu.var_name\"\n    headers = list(columns)  # copy of the mutable list\n    for i, col_header in enumerate(headers):\n        if isinstance(col_header, tuple):\n            headers[i] = f\"{col_header[0]}.{col_header[1]}\"\n\n    df_results.to_csv(filename, columns=columns, header=headers, index=False)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.start","title":"start","text":"<pre><code>start(\n    conf_path: str,\n    fixed_point_init=False,\n    fixed_point_kwargs=None,\n)\n</code></pre> <p>Start the coordinator with the given configuration file.</p> PARAMETER DESCRIPTION <code>conf_path</code> <p>path to the configuration file.</p> <p> TYPE: <code>str</code> </p> <code>fixed_point_init</code> <p>whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fixed_point_kwargs</code> <p>keyword arguments for the fixed point initialization method if fixed_point is set to True. Defaults to None, in which case the default values are used \"solver\": \"fsolve\", \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def start(self, conf_path: str, fixed_point_init=False, fixed_point_kwargs=None):\n    \"\"\"\n    Start the coordinator with the given configuration file.\n\n    Args:\n        conf_path (str): path to the configuration file.\n        fixed_point_init (bool): whether to use the fixed-point initialization method.\n        fixed_point_kwargs (dict): keyword arguments for the fixed point initialization\n            method if fixed_point is set to True. Defaults to None, in which\n            case the default values are used \"solver\": \"fsolve\",\n            \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.\n    \"\"\"\n\n    # 1. Start ConfigParser and parse the configuration file\n    self.parse_config(conf_path)\n\n    # 2. Start GraphEngine\n    self.start_graph_engine(self.config_parser.graph_config)\n\n    # 3. Start Master\n    self.config_parser.master_config[\"sequence_order\"] = (\n        self.graph_engine.sequence_order\n    )\n    self.start_master(\n        self.config_parser.master_config,\n        fixed_point_init=fixed_point_init,\n        fixed_point_kwargs=fixed_point_kwargs,\n    )\n\n    # 4. Create DataStreamHandlers\n    self.load_stream_handlers(self.config_parser.stream_handlers)\n\n    # 5. Create DataStorages\n    self.storage_handler = StorageHandler()\n    self.load_data_storages(self.config_parser.data_storages)\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.start_graph_engine","title":"start_graph_engine","text":"<pre><code>start_graph_engine(config: dict)\n</code></pre> <p>Start the graph engine with the given configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration for the graph engine containing the FMUs, connections, and edge separation.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def start_graph_engine(self, config: dict):\n    \"\"\"\n    Start the graph engine with the given configuration.\n\n    Args:\n        config (dict): configuration for the graph engine containing the FMUs,\n            connections, and edge separation.\n    \"\"\"\n    self.graph_engine = GraphEngine(\n        config[\"fmus\"],\n        config[\"symbolic_nodes\"],\n        config[\"connections\"],\n        config[\"edge_sep\"],\n    )\n</code></pre>"},{"location":"api/coordinator/#cofmupy.coordinator.Coordinator.start_master","title":"start_master","text":"<pre><code>start_master(\n    config: dict,\n    fixed_point_init=False,\n    fixed_point_kwargs=None,\n)\n</code></pre> <p>Start the master algorithm with the given configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration for the master algorithm containing the FMUs, connections, sequence order, and loop method.</p> <p> TYPE: <code>dict</code> </p> <code>fixed_point_init</code> <p>whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fixed_point_kwargs</code> <p>keyword arguments for the fixed point initialization method if fixed_point is set to True. Defaults to None, in which case the default values are used \"solver\": \"fsolve\", \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> Source code in <code>cofmupy/coordinator.py</code> <pre><code>def start_master(\n    self, config: dict, fixed_point_init=False, fixed_point_kwargs=None\n):\n    \"\"\"\n    Start the master algorithm with the given configuration.\n\n    Args:\n        config (dict): configuration for the master algorithm containing the FMUs,\n            connections, sequence order, and loop method.\n        fixed_point_init (bool): whether to use the fixed-point initialization method.\n        fixed_point_kwargs (dict): keyword arguments for the fixed point initialization\n            method if fixed_point is set to True. Defaults to None, in which\n            case the default values are used \"solver\": \"fsolve\",\n            \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.\n    \"\"\"\n    self.master = DefaultMaster(\n        fmu_config_list=config[\"fmus\"],\n        connections=config[\"connections\"],\n        sequence_order=config[\"sequence_order\"],\n        cosim_method=config[\"cosim_method\"],\n        iterative=config[\"iterative\"],\n        fixed_point=fixed_point_init,\n        fixed_point_kwargs=fixed_point_kwargs,\n    )\n    self.master.init_simulation(input_dict={})\n</code></pre>"},{"location":"api/graph_engine/","title":"The Cosimulation Graph Engine","text":"<p>GraphEngine is a class that represents a graph structure based on * FMUs and/or symbolic nodes * connections (namely edges) It uses networkx library to build and manipulate the graph.</p> <p>Custom dependencies: the method plot_graph uses GraphPlotter</p> <p>Initialize the GraphEngine instance, set up the FMU and connection lists, and construct the graph.</p> PARAMETER DESCRIPTION <code>fmu_list</code> <p>List of FMU data (each FMU represented as a dictionary).</p> <p> TYPE: <code>List[Dict]</code> </p> <code>symbolic_nodes</code> <p>List of symbolic nodes (each node represented as a dictionary).</p> <p> TYPE: <code>List[Dict]</code> </p> <code>conn_list</code> <p>List of connections (each connection represented as a dictionary).</p> <p> TYPE: <code>List[Dict]</code> </p> <code>edge_sep</code> <p>Separator used for edge labels. Default is \" -&gt; \".</p> <p> TYPE: <code>str</code> DEFAULT: <code>' -&gt; '</code> </p> Source code in <code>cofmupy/graph_engine.py</code> <pre><code>def __init__(\n    self,\n    fmu_list: List[Dict],\n    symbolic_nodes: List[Dict],\n    conn_list: List[Dict],\n    edge_sep: str = \" -&gt; \",\n) -&gt; None:\n    \"\"\"\n    Initialize the GraphEngine instance, set up the FMU and connection lists,\n    and construct the graph.\n\n    Args:\n        fmu_list (List[Dict]): List of FMU data (each FMU represented as a\n            dictionary).\n        symbolic_nodes (List[Dict]): List of symbolic nodes (each node represented\n            as a dictionary).\n        conn_list (List[Dict]): List of connections (each connection represented as\n            a dictionary).\n        edge_sep (str, optional): Separator used for edge labels.\n            Default is \" -&gt; \".\n    \"\"\"\n\n    self.fmu_list = fmu_list\n    self.symbolic_nodes = symbolic_nodes\n    self.conn_list = conn_list\n    self.edge_sep = edge_sep\n    self.keys = Keys()\n    self.color_map = {}\n\n    # Build Graph\n    self.graph, self.fmu_types = self._create_graph()\n\n    # Create connections and get order\n    self.connections = self._name_connections()\n    self.sequence_order = self._get_order()\n</code></pre>"},{"location":"api/graph_engine/#cofmupy.graph_engine.GraphEngine.plot_graph","title":"plot_graph","text":"<pre><code>plot_graph(savefig=False)\n</code></pre> <p>Plot a graph representation of the co-simulation diagram.</p> <p>This method generates a Plotly figure showing nodes and their connections. It uses NetworkX for node positioning and Plotly for rendering the graph.</p> PARAMETER DESCRIPTION <code>savefig</code> <p>Whether to save the figure as an HTML file. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>go.Figure: The Plotly figure object representing the co-simulation diagram.</p> Source code in <code>cofmupy/graph_engine.py</code> <pre><code>def plot_graph(self, savefig: bool = False) -&gt; go.Figure:\n    \"\"\"\n    Plot a graph representation of the co-simulation diagram.\n\n    This method generates a Plotly figure showing nodes and their connections.\n    It uses NetworkX for node positioning and Plotly for rendering the graph.\n\n    Args:\n        savefig (bool, optional): Whether to save the figure as an HTML file. Defaults to False.\n\n    Returns:\n        go.Figure: The Plotly figure object representing the co-simulation diagram.\n    \"\"\"\n\n    plotter = GraphPlotter()\n\n    size_map = {k: 1 if v == \"fmu\" else 0.2 for k, v in self.fmu_types.items()}\n\n    fig = plotter.generate_figure(\n        self.graph, self.fmu_list + self.symbolic_nodes, size_map\n    )\n\n    self.color_map = plotter.color_map\n\n    if savefig:\n        plotter.save_plotly_figure(fig, \"cosim_diagram\")\n\n    return fig\n</code></pre>"},{"location":"api/master/","title":"The Cosimulation Master","text":"<p>Module for managing and executing co-simulations involving multiple FMUs.</p> <p>This module provides a <code>DefaultMaster</code> class that handles FMU initialization, input setting, stepping, and result collection during simulation.</p>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster","title":"DefaultMaster","text":"<pre><code>DefaultMaster(\n    fmu_config_list,\n    connections,\n    sequence_order,\n    cosim_method=\"jacobi\",\n    iterative=False,\n    fixed_point=False,\n    fixed_point_kwargs=None,\n)\n</code></pre> <p>Manages and executes the co-simulation involving multiple FMUs.</p> ATTRIBUTE DESCRIPTION <code>fmu_config_list</code> <p>A list of dictionaries containing information about the FMUs to be used in the simulation.</p> <p> TYPE: <code>list</code> </p> <code>connections</code> <p>A dictionary of connections between FMUs. The keys are tuples (source_fmu, source_variable), and the values are dictionaries with information about the source and target FMUs and variables.</p> <p> TYPE: <code>dict</code> </p> <code>sequence_order</code> <p>The order in which FMUs should be executed.</p> <p> TYPE: <code>list</code> </p> <code>cosim_method</code> <p>The method used to solve algebraic loops in the simulation.</p> <p> TYPE: <code>str</code> </p> <code>current_time</code> <p>The current simulation time.</p> <p> TYPE: <code>float</code> </p> <code>fixed_point</code> <p>Whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> </p> <code>fixed_point_kwargs</code> <p>Keyword arguments for the fixed-point initialization method.</p> <p> TYPE: <code>dict</code> </p> METHOD DESCRIPTION <code>sanity_check</code> <p>Checks FMU compatibility, I/Os, and headers with the corresponding algorithm.</p> <code>set_inputs</code> <p>Sets the input values for the current simulation step using the provided input dictionary.</p> <code>init_simulation</code> <p>Initializes the simulation environment and FMUs.</p> <code>get_outputs</code> <p>Returns the output dictionary for the current step.</p> <code>get_results</code> <p>Returns the results of the simulation.</p> <code>solve_loop</code> <p>Uses the defined algorithm to solve algebraic loops in the simulation.</p> <code>do_step</code> <p>Performs a single step of the simulation, updating inputs, executing FMUs, and propagating outputs.</p> <p>Initializes the Master class with FMU configurations, connection details, sequence order, and loop solver.</p> PARAMETER DESCRIPTION <code>fmu_config_list</code> <p>List of dictionaries with FMU configurations.</p> <p> TYPE: <code>list</code> </p> <code>connections</code> <p>Dictionary mapping connections between FMUs.</p> <p> TYPE: <code>dict</code> </p> <code>sequence_order</code> <p>Execution order of FMUs.</p> <p> TYPE: <code>list</code> </p> <code>cosim_method</code> <p>Strategy for coordinating FMUs in co-simulation. Options are \"jacobi\" and \"gauss-seidel\". Defaults to \"jacobi\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'jacobi'</code> </p> <code>iterative</code> <p>Whether to solve algebraic loops iteratively. Defaults to False.</p> <p> TYPE: <code>str</code> DEFAULT: <code>False</code> </p> <code>fixed_point</code> <p>whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fixed_point_kwargs</code> <p>keyword arguments for the fixed point</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def __init__(\n    self,\n    fmu_config_list: list,\n    connections: dict,\n    sequence_order: list,\n    cosim_method: str = \"jacobi\",\n    iterative: bool = False,\n    fixed_point=False,\n    fixed_point_kwargs=None,\n):\n    \"\"\"\n    Initializes the Master class with FMU configurations, connection details,\n    sequence order, and loop solver.\n\n    Args:\n        fmu_config_list (list): List of dictionaries with FMU configurations.\n        connections (dict): Dictionary mapping connections between FMUs.\n        sequence_order (list): Execution order of FMUs.\n        cosim_method (str, optional): Strategy for coordinating FMUs in\n            co-simulation. Options are \"jacobi\" and \"gauss-seidel\".\n            Defaults to \"jacobi\".\n        iterative (str, optional): Whether to solve algebraic loops iteratively.\n            Defaults to False.\n        fixed_point (bool): whether to use the fixed-point initialization method.\n        fixed_point_kwargs (dict): keyword arguments for the fixed point\n        initialization\n            method if fixed_point is set to True. Defaults to None, in which\n            case the default values are used \"solver\": \"fsolve\",\n            \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.\n    \"\"\"\n\n    self.fmu_config_list = (\n        fmu_config_list  # List of FMU configurations (dict) from config file\n    )\n    self.connections = connections  # Dict of connections between FMUs\n\n    # Cosimulation method (default: Jacobi)\n    self.cosim_method = cosim_method\n    # Whether iterative method requested (default: False)\n    self.iterative = iterative\n\n    # Load FMUs into dict of FMU Handlers\n    self.fmu_handlers = self._load_fmus()\n\n    # Check if the names of the variables match between the connection dict and\n    # the FMUs\n    self._check_connections()\n\n    default_step_sizes = []\n    for fmu in self.fmu_handlers.values():\n        default_step_sizes.append(fmu.default_step_size)\n\n    ## find the smaller of all step sizes\n    # remove None from default_step_sizes\n    default_step_sizes = [x for x in default_step_sizes if x is not None]\n    if len(default_step_sizes) == 0:\n        self.default_step_size = 1.0\n    else:\n        self.default_step_size = np.min(default_step_sizes)\n\n    # Sequence order of execution as a List of FMU IDs. Extracted by config\n    # parser module\n    # Sequence order of execution as a List of FMU IDs. Extracted by config parser\n    self.sequence_order = sequence_order\n    if self.sequence_order is None:\n        self.sequence_order = [d[self.__keys[\"id\"]] for d in self.fmu_config_list]\n\n    # init current_time to None to check if init_simulation() has been called\n    self.current_time = None\n    # Init output and input dictionaries for FMUs to maintain state between steps\n    # Initialize arrays for inputs and outputs\n    self._input_dict = {\n        fmu_id: np.zeros(len(fmu.get_input_names()))\n        for fmu_id, fmu in self.fmu_handlers.items()\n    }\n\n    self._output_dict = {\n        fmu_id: np.zeros(len(fmu.get_output_names()))\n        for fmu_id, fmu in self.fmu_handlers.items()\n    }\n    # Results dictionary to store the output values for each step\n    self._results = defaultdict(list)\n\n    self.fixed_point = fixed_point\n    self.fixed_point_kwargs = fixed_point_kwargs\n\n    if fixed_point and fixed_point_kwargs is None:\n        self.fixed_point_kwargs = {\n            \"solver\": \"fsolve\",\n            \"time_step\": self.default_step_size,\n            \"xtol\": 1e-5,\n        }\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.variable_names","title":"variable_names  <code>property</code>","text":"<pre><code>variable_names\n</code></pre> <p>Get the names of all variables in the system.</p> RETURNS DESCRIPTION <code>list</code> <p>list of variable names as (fmu_id, var_name) tuples.</p> <p> TYPE: <code>list[tuple[str, str]]</code> </p>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.apply_fmu_outputs_to_inputs","title":"apply_fmu_outputs_to_inputs","text":"<pre><code>apply_fmu_outputs_to_inputs(\n    input_to_update, fmu_id, out_fmu\n)\n</code></pre> <p>Performs a copy of output values into input dict. The copy is based on connections between given fmu/outputs and inpout dict for each FMU.</p> PARAMETER DESCRIPTION <code>out_fmu</code> <p>A dictionary containing the output values for the current step on a given fmu, identified by fmu_id</p> <p> TYPE: <code>dict</code> </p> <code>fmu_id</code> <p>A String identifying FMU into system. Used to find connections with outputs</p> <p> TYPE: <code>str</code> </p> <code>input_to_update</code> <p>input dict to update</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <p>No return, at the end of the method, input_to_update is fill with updated values.</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def apply_fmu_outputs_to_inputs(\n    self, input_to_update: dict, fmu_id: str, out_fmu: dict\n):\n    \"\"\"\n    Performs a copy of output values into input dict.\n    The copy is based on connections between given fmu/outputs and inpout dict for\n    each FMU.\n\n    Args:\n        out_fmu: A dictionary containing the output values for the current step\n            on a given fmu, identified by fmu_id\n        fmu_id: A String identifying FMU into system. Used to find connections with\n            outputs\n        input_to_update: input dict to update\n\n    Returns:\n        No return, at the end of the method, input_to_update is fill with updated\n            values.\n    \"\"\"\n    for output_name, value in out_fmu.items():\n        self.update_connected_inputs(input_to_update, fmu_id, output_name, value)\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.do_fixed_point_step","title":"do_fixed_point_step","text":"<pre><code>do_fixed_point_step(step_size, input_dict=None)\n</code></pre> <p>This method updates the input dictionary with the values from the provided input dictionary, performs a single step of the simulation on each FMU, using the default jacobi method, propagates the output values to the corresponding variables for the next step, and updates the current simulation time accordingly. It also stores the output values in the results dictionary.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>The size of the simulation step.</p> <p> TYPE: <code>float</code> </p> <code>input_dict</code> <p>A dictionary containing input values for the simulation. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>record_outputs</code> <p>Whether to store the output values in the results dictionary. Defaults to True.</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the output values for this step, structured as <code>[FMU_ID][Var]</code>.</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def do_fixed_point_step(self, step_size: float, input_dict=None):\n    \"\"\"\n    This method updates the input dictionary with the values from the provided input\n    dictionary, performs a single step of the simulation on each FMU, using the\n    default jacobi method, propagates the output values to the corresponding\n    variables for the next step, and updates the current simulation time accordingly. It also\n    stores the output values in the results dictionary.\n\n    Args:\n        step_size (float): The size of the simulation step.\n        input_dict (dict, optional): A dictionary containing input values for the\n            simulation. Defaults to None.\n        record_outputs (bool, optional): Whether to store the output values in the\n            results dictionary. Defaults to True.\n\n    Returns:\n        dict: A dictionary containing the output values for this step, structured as\n            `[FMU_ID][Var]`.\n\n    \"\"\"\n    self.set_inputs(input_dict=input_dict)\n    for fmu_ids in self.sequence_order:\n        # out is fill with key: fmu_id, value: output_dict (var_name, value)\n        out = self.solve_loop(fmu_ids, step_size)\n\n        for fmu_id, fmu_output_dict in out.items():\n            for output_name, value in fmu_output_dict.items():\n\n                # add each output to the output dict, [FMU_ID][Var] as key\n                self._output_dict[fmu_id][output_name] = value\n\n    # update 1 for all inputs with outputs\n    for fmu_id, fmu_output_dict in self._output_dict.items():\n        self.apply_fmu_outputs_to_inputs(self._input_dict, fmu_id, fmu_output_dict)\n    self.current_time += step_size\n    # Return the output value for this step\n    return self._output_dict\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.do_step","title":"do_step","text":"<pre><code>do_step(step_size, input_dict=None, record_outputs=True)\n</code></pre> <p>This method updates the input dictionary with the values from the provided input dictionary, performs a single step of the simulation on each FMU, using the solve_loop method, propagates the output values to the corresponding variables for the next step, and updates the current simulation time accordingly. It also stores the output values in the results dictionary.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>The size of the simulation step.</p> <p> TYPE: <code>float</code> </p> <code>input_dict</code> <p>A dictionary containing input values for the simulation. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>record_outputs</code> <p>Whether to store the output values in the results dictionary. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the output values for this step, structured as <code>[FMU_ID][Var]</code>.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def do_step(self, step_size: float, input_dict=None, record_outputs=True) -&gt; dict:\n    \"\"\"\n    This method updates the input dictionary with the values from the provided input\n    dictionary, performs a single step of the simulation on each FMU, using the\n    solve_loop method, propagates the output values to the corresponding variables\n    for the next step, and updates the current simulation time accordingly. It also\n    stores the output values in the results dictionary.\n\n    Args:\n        step_size (float): The size of the simulation step.\n        input_dict (dict, optional): A dictionary containing input values for the\n            simulation. Defaults to None.\n        record_outputs (bool, optional): Whether to store the output values in the\n            results dictionary. Defaults to True.\n\n    Returns:\n        dict: A dictionary containing the output values for this step, structured as\n            `[FMU_ID][Var]`.\n\n    \"\"\"\n    self.set_inputs(input_dict=input_dict)\n    if record_outputs:\n        self._results[\"time\"].append(self.current_time)\n    for fmu_ids in self.sequence_order:\n        # out is fill with key: fmu_id, value: output_dict (var_name, value)\n        out = self.solve_loop(\n            fmu_ids, step_size, algo=self.cosim_method, iterative=self.iterative\n        )\n\n        for fmu_id, fmu_output_dict in out.items():\n            for output_name, value in fmu_output_dict.items():\n                # Update inputs connected to FMU outputs\n                self.update_connected_inputs(\n                    self._input_dict, fmu_id, output_name, value\n                )\n                if record_outputs:\n                    # add each output to the result dict, (FMU_ID + Var) as key\n                    self._results[(fmu_id, output_name)].extend(value)\n\n                # add each output to the output dict, [FMU_ID][Var] as key\n                self._output_dict[fmu_id][output_name] = value\n\n    self.current_time += step_size\n    # Return the output value for this step\n    return self._output_dict\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.get_causality","title":"get_causality","text":"<pre><code>get_causality(name)\n</code></pre> <p>Gets the causality of the given variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>str</code> <p>causality of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def get_causality(self, name: tuple[str, str]) -&gt; str:\n    \"\"\"\n    Gets the causality of the given variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        str: causality of the variable.\n    \"\"\"\n    fmu_id, var_name = name\n    return self.fmu_handlers[fmu_id].get_causality(var_name)\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.get_input_dict","title":"get_input_dict","text":"<pre><code>get_input_dict()\n</code></pre> <p>Returns the input dictionary for the current step.</p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the input values for the current step, structured as <code>[fmu_id][variable_name] =&gt; list(value)</code>.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def get_input_dict(self) -&gt; dict:\n    \"\"\"\n    Returns the input dictionary for the current step.\n\n    Returns:\n        dict: A dictionary containing the input values for the current step,\n            structured as `[fmu_id][variable_name] =&gt; list(value)`.\n    \"\"\"\n    return self._input_dict\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.get_outputs","title":"get_outputs","text":"<pre><code>get_outputs()\n</code></pre> <p>Returns the output dictionary for the current step.</p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the output values of the current step, structured as <code>[FMU_ID][Var]</code>.</p> <p> TYPE: <code>dict[str, list]</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def get_outputs(self) -&gt; dict[str, list]:\n    \"\"\"\n    Returns the output dictionary for the current step.\n\n    Returns:\n        dict: A dictionary containing the output values of the current step,\n            structured as `[FMU_ID][Var]`.\n    \"\"\"\n    return self._output_dict\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.get_residual","title":"get_residual","text":"<pre><code>get_residual(input_dict, output_dict)\n</code></pre> <p>Performs check between outputs and connected inputs and return a list of residuals The check is based on connections between given fmu/outputs and inpout dict for each FMU.</p> PARAMETER DESCRIPTION <code>output_dict</code> <p>A dictionary containing the output values for the current step</p> <p> TYPE: <code>dict</code> </p> <code>input_dict</code> <p>Input dict concerned by the check, transient dict with current calculated values</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>residuals</code> <p>A list of residuals between inputs and outputs (1 for each connection)</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def get_residual(self, input_dict: dict, output_dict: dict):\n    \"\"\"\n    Performs check between outputs and connected inputs and return a list of\n    residuals\n    The check is based on connections between given fmu/outputs and inpout dict for\n    each FMU.\n\n    Args:\n        output_dict: A dictionary containing the output values for the current step\n        input_dict: Input dict concerned by the check, transient dict with current\n            calculated values\n\n    Returns:\n        residuals: A list of residuals between inputs and outputs\n            (1 for each connection)\n    \"\"\"\n    residuals = {}\n    for fmu_id, out_fmu in output_dict.items():\n        for output_name, value in out_fmu.items():\n            if (fmu_id, output_name) in self.connections:\n                for target_fmu, target_variable in self.connections[\n                    (fmu_id, output_name)\n                ]:\n                    residuals[target_fmu + \"_\" + target_variable] = np.abs(\n                        input_dict[target_fmu][target_variable][0] - value[0]\n                    )\n\n    return residuals\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.get_results","title":"get_results","text":"<pre><code>get_results()\n</code></pre> <p>Returns the results of the simulation, this includes the values of every output variables, for each step, up until the current time of simulation.</p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionnary containing output values of every step, structured as [(FMU_ID, Var)]</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def get_results(self) -&gt; dict:\n    \"\"\"\n    Returns the results of the simulation, this includes the values of every output\n    variables, for each step, up until the current time of simulation.\n\n    Returns:\n        dict: A dictionnary containing output values of every step, structured as\n            [(FMU_ID, Var)]\n\n    \"\"\"\n    return self._results\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.get_variable","title":"get_variable","text":"<pre><code>get_variable(name)\n</code></pre> <p>Get the value of the given tuple fmu/variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>list</code> <p>value of the variable, as a list.</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def get_variable(self, name: tuple[str, str]):\n    \"\"\"\n    Get the value of the given tuple fmu/variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        list: value of the variable, as a list.\n    \"\"\"\n    fmu_id, var_name = name\n    return self.fmu_handlers[fmu_id].get_variable(var_name)\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.get_variable_type","title":"get_variable_type","text":"<pre><code>get_variable_type(name)\n</code></pre> <p>Get the type of the given variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>str</code> <p>type of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def get_variable_type(self, name: tuple[str, str]) -&gt; str:\n    \"\"\"\n    Get the type of the given variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        str: type of the variable.\n    \"\"\"\n    fmu_id, var_name = name\n    return self.fmu_handlers[fmu_id].get_variable_type(var_name)\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.init_simulation","title":"init_simulation","text":"<pre><code>init_simulation(input_dict=None)\n</code></pre> <p>Initializes the simulation environment and FMUs.</p> <p>This method sets up the necessary dictionaries for the simulation and initializes the FMUs with either a fixed point algorithm or values provided in the input dictionary.</p> PARAMETER DESCRIPTION <code>input_dict</code> <p>A dictionary containing input values for the simulation. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> The method performs the following steps <ol> <li>Sets the current simulation time to 0.</li> <li>If fixed_point is True, calls the _fixed_point_init() method.</li> <li>Otherwise, sets the inputs using the provided input_dict and initializes     each FMU with these values.</li> </ol> <p>Note: The FMUs are reset after setting the initial values.</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def init_simulation(self, input_dict=None):\n    \"\"\"\n    Initializes the simulation environment and FMUs.\n\n    This method sets up the necessary dictionaries for the simulation and\n    initializes the FMUs with either a fixed point algorithm or values provided in\n    the input dictionary.\n\n    Args:\n        input_dict (dict): A dictionary containing input values for the simulation.\n            Defaults to None.\n\n    The method performs the following steps:\n        1. Sets the current simulation time to 0.\n        2. If fixed_point is True, calls the _fixed_point_init() method.\n        3. Otherwise, sets the inputs using the provided input_dict and initializes\n            each FMU with these values.\n\n    **Note**: The FMUs are reset after setting the initial values.\n    \"\"\"\n\n    # # Init output and input dictionaries\n    for fmu_id, fmu in self.fmu_handlers.items():\n        self._output_dict[fmu_id] = {key: [0] for key in fmu.get_output_names()}\n        self._input_dict[fmu_id] = {key: [0] for key in fmu.get_input_names()}\n\n    # Init current_time of simulation to 0\n    self.current_time = 0.0\n\n    # Init input/output/parameter variables with the values provided in the config\n    self.initialize_values_from_config()\n\n    # INIT: call fixed_step()\n    if self.fixed_point:\n        print(\"Calling Fixed Point Initialization\")\n        self.set_inputs(input_dict=input_dict)\n        fixed_point_solver = FixedPointInitializer(self, **self.fixed_point_kwargs)\n        fixed_point_solution = fixed_point_solver.solve()\n        self.set_inputs(input_dict=fixed_point_solution)\n    else:\n        print(\"Skipping Fixed Point Initialization\")\n        self.set_inputs(input_dict=input_dict)\n\n    for fmu_id, fmu_handler in self.fmu_handlers.items():\n        init_dict = self._input_dict[fmu_id]\n        fmu_handler.set_variables(init_dict)\n        fmu_handler.reset()\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.initialize_values_from_config","title":"initialize_values_from_config","text":"<pre><code>initialize_values_from_config()\n</code></pre> <p>Initializes the FMU variables (inputs/outputs/parameters) with the values provided in the configuration dict.</p> <p>If the variable is an input, it is also added to the input dictionary</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def initialize_values_from_config(self):\n    \"\"\"\n    Initializes the FMU variables (inputs/outputs/parameters) with the values\n    provided in the configuration dict.\n\n    If the variable is an input, it is also added to the input dictionary\n    \"\"\"\n    if self.current_time is None:\n        raise RuntimeError(\n            \"Current time is not initialized. Call init_simulation() first.\"\n        )\n\n    for fmu in self.fmu_config_list:\n        fmu_handler = self.fmu_handlers[fmu[self.__keys[\"id\"]]]\n        for key, value in fmu[self.__keys[\"init\"]].items():\n            fmu_handler.set_variables({key: [value]})\n            if key in fmu_handler.get_input_names():\n                self._input_dict[fmu[self.__keys[\"id\"]]][key] = [value]\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.sanity_check","title":"sanity_check","text":"<pre><code>sanity_check()\n</code></pre> <p>Checks the compatibility of FMUs, including input/output validation and algorithm compliance.</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def sanity_check(self):  # TODO\n    \"\"\"\n    Checks the compatibility of FMUs, including input/output validation and\n    algorithm compliance.\n    \"\"\"\n    self._check_connections()\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.set_inputs","title":"set_inputs","text":"<pre><code>set_inputs(input_dict=None)\n</code></pre> <p>Sets the input values for the current simulation step.</p> <p>This method populates the internal input dictionary (<code>self._input_dict</code>) with values for the current step. It updates these values with those provided in the <code>input_dict</code> parameter, if given. The <code>input_dict</code> parameter is expected to be a dictionary of dictionaries, where each key is an FMU identifier and each value is another dictionary mapping variable names to their respective values (e.g., {\"FMU1\": {\"var1\": value}, \"FMU2\": {\"var2\": val, \"var3\": val}}).</p> PARAMETER DESCRIPTION <code>input_dict</code> <p>A dictionary of dictionaries containing input values to override the initialization values. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the current simulation time (<code>self.current_time</code>) is not initialized. Ensure that init_simulation()` is called before invoking this method.</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def set_inputs(self, input_dict=None):\n    \"\"\"\n    Sets the input values for the current simulation step.\n\n    This method populates the internal input dictionary (`self._input_dict`) with\n    values for the current step. It updates these values with those provided in the\n    `input_dict` parameter, if given. The `input_dict` parameter is expected to be\n    a dictionary of dictionaries, where each key is an FMU identifier and each value\n    is another dictionary mapping variable names to their respective values (e.g.,\n    {\"FMU1\": {\"var1\": value}, \"FMU2\": {\"var2\": val, \"var3\": val}}).\n\n    Args:\n        input_dict (dict, optional): A dictionary of dictionaries containing input\n            values to override the initialization values. Defaults to None.\n\n    Raises:\n        RuntimeError: If the current simulation time (`self.current_time`) is not\n            initialized. Ensure that init_simulation()` is called before invoking\n            this method.\n    \"\"\"\n    if self.current_time is None:\n        raise RuntimeError(\n            \"Current time is not initialized. Call init_simulation() first.\"\n        )\n\n    if input_dict:  # True if input_dict is not empty\n        for fmu in input_dict:\n            if fmu not in self.fmu_handlers:\n                raise ValueError(\n                    f\"FMU '{fmu}' not found in FMUs: \"\n                    f\"{list(self.fmu_handlers.keys())}.\"\n                )\n            for variable in input_dict[fmu]:\n                if (\n                    variable\n                    not in self.fmu_handlers[fmu].get_input_names()\n                    + self.fmu_handlers[fmu].get_parameter_names()\n                ):\n                    raise ValueError(\n                        f\"Variable '{variable}' not found in inputs of FMU '{fmu}':\"\n                        f\" {self.fmu_handlers[fmu].get_input_names()}.\"\n                    )\n                # Set given values (will overide values set previously in init)\n                self._input_dict[fmu][variable] = input_dict[fmu][variable]\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.solve_loop","title":"solve_loop","text":"<pre><code>solve_loop(\n    fmu_ids, step_size, algo=\"jacobi\", iterative=False\n)\n</code></pre> <p>Performs a single simulation step on the given FMUs, using the defined algorithm to solve algebraic loops in the simulation.</p> <p>In the case there is no loop, the function will propagate the output values and return them.</p> PARAMETER DESCRIPTION <code>fmu_ids</code> <p>List of highly coupled FMUs. Contains only one FMU if there is no loop.</p> <p> TYPE: <code>list[str]</code> </p> <code>step_size</code> <p>The step size for data exchange (in cosimulation mode, FMU integration step is fixed).</p> <p> TYPE: <code>float</code> </p> <code>algo</code> <p>The algorithm to use to solve the loop (default: \"jacobi\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'jacobi'</code> </p> <code>iterative</code> <p>Whether iterative method requested to solve the loop.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the output values for this step of the FMUs given, structured as <code>[FMU_ID][Var]</code></p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def solve_loop(\n    self, fmu_ids, step_size: float, algo=\"jacobi\", iterative=False\n) -&gt; dict:\n    \"\"\"\n    Performs a single simulation step on the given FMUs, using the defined algorithm\n    to solve algebraic loops in the simulation.\n\n    In the case there is no loop, the function will propagate the output values and\n    return them.\n\n    Args:\n        fmu_ids (list[str]): List of highly coupled FMUs. Contains only one FMU if\n            there is no loop.\n        step_size (float): The step size for **data exchange** (in cosimulation\n            mode, FMU integration step is fixed).\n        algo (str): The algorithm to use to solve the loop (default: \"jacobi\").\n        iterative (bool): Whether iterative method requested to solve the loop.\n\n    Returns:\n        dict: A dictionary containing the output values for this step of the FMUs\n            given, structured as `[FMU_ID][Var]`\n\n    \"\"\"\n\n    # Verify algo is a known algo name\n    if algo not in (\"jacobi\", \"gauss_seidel\"):\n        raise NotImplementedError(\n            f\"Algorithm {algo} not implemented for loop solving.\"\n        )\n\n    outputs = {}  # key: fmu_id, value: output_dict (var_name, value)\n    # Copy useful inputs to local \"inputs\" variable\n    inputs = {fmu_id: self._input_dict[fmu_id] for fmu_id in fmu_ids}\n\n    current_iteration = 0\n    tol = 1e-3\n    max_iteration = 10\n    converged = False\n    fmu_states = defaultdict(list)  # variable for state storage for each FMU\n\n    while not converged and current_iteration &lt; max_iteration:\n        # Save inputs for check coherence\n        inputs_before = copy.deepcopy(inputs)\n        for fmu_id in fmu_ids:\n            fmu = self.fmu_handlers[fmu_id]\n\n            if iterative:\n                if fmu_id in fmu_states:  # If state exists =&gt; retrieve state\n                    fmu.set_state(fmu_states[fmu_id])\n                else:  # Save state\n                    fmu_states[fmu_id] = fmu.get_state()\n\n            outputs[fmu_id] = fmu.step(self.current_time, step_size, inputs[fmu_id])\n\n            # Update inputs into fmu loop, only for gauss-seidel algo\n            if algo == \"gauss_seidel\":\n                self.apply_fmu_outputs_to_inputs(inputs, fmu_id, outputs[fmu_id])\n\n        # Update inputs at the end of fmu loop, only for Jacobi algo\n        if algo == \"jacobi\":\n            for fmu_id in fmu_ids:\n                self.apply_fmu_outputs_to_inputs(inputs, fmu_id, outputs[fmu_id])\n\n        # Exit loop if not iterative or only 1 FMU inside loop\n        if not iterative or len(fmu_ids) == 1:\n            break\n\n        conv_val = True\n        residuals = self.get_residual(inputs_before, outputs)\n        for fmu_id, residual in residuals.items():\n            conv_val = conv_val and residual &lt; tol\n\n        converged = conv_val\n        current_iteration += 1\n\n    \"\"\"\n    if iterative and len(fmu_ids) != 1:\n        if current_iteration == max_iteration:\n            print(\n                str(self.current_time)\n                + \" - Max iteration reached with following solution \"\n                + str(output)\n            )\n        else:\n            print(\n                str(self.current_time)\n                + \" - Convergence found \"\n                + str(current_iteration)\n                + \" iterations\"\n            )\n    \"\"\"\n    return outputs\n</code></pre>"},{"location":"api/master/#cofmupy.master.default_master.DefaultMaster.update_connected_inputs","title":"update_connected_inputs","text":"<pre><code>update_connected_inputs(\n    input_to_update, fmu_id, output_name, value\n)\n</code></pre> <p>Performs a copy of output value into input dict. The copy is based on connections between given fmu/output name and inpout dict for each connected FMU.</p> PARAMETER DESCRIPTION <code>fmu_id</code> <p>A String identifying FMU into system. Used to find connections between inputs and output</p> <p> TYPE: <code>str</code> </p> <code>output_name</code> <p>A string that identifies name of the output. Used to find connections with inputs</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>the value to copy to inputs</p> <p> </p> <code>input_to_update</code> <p>input dict to update</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <p>No return, at the end of the method, input_to_update is fill with updated value.</p> Source code in <code>cofmupy/master/default_master.py</code> <pre><code>def update_connected_inputs(\n    self, input_to_update: dict, fmu_id: str, output_name: str, value\n):\n    \"\"\"\n    Performs a copy of output value into input dict.\n    The copy is based on connections between given fmu/output name and inpout dict\n    for each connected FMU.\n\n    Args:\n        fmu_id: A String identifying FMU into system. Used to find connections\n            between inputs and output\n        output_name: A string that identifies name of the output. Used to find\n            connections with inputs\n        value: the value to copy to inputs\n        input_to_update: input dict to update\n\n    Returns:\n        No return, at the end of the method, input_to_update is fill with updated\n            value.\n    \"\"\"\n    # If output is connected, transfer the value to the connected FMU(s)\n    if (fmu_id, output_name) in self.connections:\n        for target_fmu, target_variable in self.connections[(fmu_id, output_name)]:\n            if target_fmu in input_to_update:\n                input_to_update[target_fmu][target_variable] = value\n</code></pre>"},{"location":"api/wrappers/","title":"FMU Wrappers","text":"<p>FMU wrapper classes for FMI 2.0 and FMI 3.0.</p> <p>This module contains the FMU handler classes for FMI 2.0 and FMI 3.0. These classes are used to load FMU files and interact with loaded FMUs.</p>"},{"location":"api/wrappers/#cofmupy.wrappers.Fmu2Handler","title":"Fmu2Handler","text":"<pre><code>Fmu2Handler(path, fmu_slave)\n</code></pre> <p>               Bases: <code>FmuXHandler</code></p> <p>Handler class for FMU in FMI version 2.0.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def __init__(self, path: str, fmu_slave):\n    \"\"\"Initializes the FMU handler with the given path and FMU slave class.\n\n    Args:\n        path (str): The path of .fmu file to open\n        fmu_slave (class): The FMU slave class of FMPy to use to open the fmu\n    \"\"\"\n    # read the model description\n    self.description = read_model_description(path)\n\n    self.default_step_size = (\n        self.description.defaultExperiment.stepSize\n        if self.description.defaultExperiment\n        else None\n    )\n\n    # Create a dictionary to map variable names to attributes\n    self.var_name2attr = {}\n    for variable in self.description.modelVariables:\n        self.var_name2attr[variable.name] = variable\n\n    # extract the FMU and instantiate the slave\n    unzipdir = extract(path)\n    fmu_name = os.path.basename(path)\n\n    self.fmu = fmu_slave(\n        guid=self.description.guid,\n        unzipDirectory=unzipdir,\n        modelIdentifier=self.description.coSimulation.modelIdentifier,\n        instanceName=fmu_name,\n    )\n\n    # Get the output variable names\n    self.output_var_names = []\n    self.output_var_names = list(self.get_output_names())\n\n    # Instantiate the FMU\n    self.fmu.instantiate(loggingOn=False)\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.Fmu2Handler.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the FMU to its initial state and sets up the experiment.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the FMU to its initial state and sets up the experiment.\"\"\"\n    self.fmu.setupExperiment(startTime=0.0)\n    self.fmu.enterInitializationMode()\n    self.fmu.exitInitializationMode()\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.Fmu2Handler.step","title":"step","text":"<pre><code>step(current_time, step_size, input_dict)\n</code></pre> <p>Performs a simulation step with the given current time, step size, and input values.</p> PARAMETER DESCRIPTION <code>current_time</code> <p>the current simulation time.</p> <p> TYPE: <code>float</code> </p> <code>step_size</code> <p>the size of the simulation step.</p> <p> TYPE: <code>float</code> </p> <code>input_dict</code> <p>dictionary containing input variable names and their corresponding values.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary containing output variable names and their corresponding values after the simulation step.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def step(self, current_time: float, step_size: float, input_dict: dict) -&gt; dict:\n    \"\"\"\n    Performs a simulation step with the given current time, step size, and input\n    values.\n\n    Args:\n        current_time (float): the current simulation time.\n        step_size (float): the size of the simulation step.\n        input_dict (dict): dictionary containing input variable names and their\n            corresponding values.\n\n    Returns:\n        Dictionary containing output variable names and their corresponding values\n            after the simulation step.\n    \"\"\"\n    # Set all the input variable that are given\n    for name, value in input_dict.items():\n        self.fmu.setReal([self.var_name2attr[name].valueReference], value)\n        # print(f\"{name} : {value}\")\n\n    self.fmu.doStep(\n        currentCommunicationPoint=current_time, communicationStepSize=step_size\n    )\n    result = {\n        name: self.fmu.getReal([self.var_name2attr[name].valueReference])\n        for name in self.get_output_names()\n    }\n    return result\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.Fmu3Handler","title":"Fmu3Handler","text":"<pre><code>Fmu3Handler(path, fmu_slave)\n</code></pre> <p>               Bases: <code>FmuXHandler</code></p> <p>Handler class for FMU in FMI version 3.0.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def __init__(self, path: str, fmu_slave):\n    \"\"\"Initializes the FMU handler with the given path and FMU slave class.\n\n    Args:\n        path (str): The path of .fmu file to open\n        fmu_slave (class): The FMU slave class of FMPy to use to open the fmu\n    \"\"\"\n    # read the model description\n    self.description = read_model_description(path)\n\n    self.default_step_size = (\n        self.description.defaultExperiment.stepSize\n        if self.description.defaultExperiment\n        else None\n    )\n\n    # Create a dictionary to map variable names to attributes\n    self.var_name2attr = {}\n    for variable in self.description.modelVariables:\n        self.var_name2attr[variable.name] = variable\n\n    # extract the FMU and instantiate the slave\n    unzipdir = extract(path)\n    fmu_name = os.path.basename(path)\n\n    self.fmu = fmu_slave(\n        guid=self.description.guid,\n        unzipDirectory=unzipdir,\n        modelIdentifier=self.description.coSimulation.modelIdentifier,\n        instanceName=fmu_name,\n    )\n\n    # Get the output variable names\n    self.output_var_names = []\n    self.output_var_names = list(self.get_output_names())\n\n    # Instantiate the FMU\n    self.fmu.instantiate(loggingOn=False)\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.Fmu3Handler.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the FMU to its initial state</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the FMU to its initial state\"\"\"\n    self.fmu.enterInitializationMode()\n    self.fmu.exitInitializationMode()\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.Fmu3Handler.step","title":"step","text":"<pre><code>step(current_time, step_size, input_dict)\n</code></pre> <p>Performs a simulation step with the given current time, step size, and input values.</p> PARAMETER DESCRIPTION <code>current_time</code> <p>the current simulation time.</p> <p> TYPE: <code>float</code> </p> <code>step_size</code> <p>the size of the simulation step.</p> <p> TYPE: <code>float</code> </p> <code>input_dict</code> <p>dictionary containing input variable names and their corresponding values.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary containing output variable names and their corresponding values after the simulation step.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def step(self, current_time: float, step_size: float, input_dict: dict) -&gt; dict:\n    \"\"\"\n    Performs a simulation step with the given current time, step size, and input\n    values.\n\n    Args:\n        current_time (float): the current simulation time.\n        step_size (float): the size of the simulation step.\n        input_dict (dict): dictionary containing input variable names and their\n            corresponding values.\n\n    Returns:\n        Dictionary containing output variable names and their corresponding values\n            after the simulation step.\n    \"\"\"\n    # Set all the input variable that are given\n    for name, value in input_dict.items():\n        if self.var_name2attr[name].type == \"Boolean\":\n            self.fmu.setBoolean([self.var_name2attr[name].valueReference], value)\n        else:\n            self.fmu.setFloat64([self.var_name2attr[name].valueReference], value)\n        # print(f\"{name} : {value}\")\n\n    self.fmu.doStep(\n        currentCommunicationPoint=current_time, communicationStepSize=step_size\n    )\n    result = {\n        name: self.fmu.getFloat64([self.var_name2attr[name].valueReference])\n        for name in self.output_var_names\n    }\n    return result\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuHandlerFactory","title":"FmuHandlerFactory","text":"<pre><code>FmuHandlerFactory(path)\n</code></pre> <p>Factory class to create FMU handlers based on the FMI version.</p> ATTRIBUTE DESCRIPTION <code>path</code> <p>The file path to the FMU.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>The model description of the FMU.</p> <p> </p> METHOD DESCRIPTION <code>__call__</code> <p>Creates and returns an FMU handler based on the FMI version.</p> <p>Initializes the FmuHandlerFactory with the given path and reads the model description.</p> PARAMETER DESCRIPTION <code>path</code> <p>The file path to the FMU.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>FmuXHandler</code> <p>The appropriate FMU handler based on the FMI version.</p> <p> TYPE: <code>FmuXHandler</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the FMI version is not recognized.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def __init__(self, path: str) -&gt; \"FmuXHandler\":\n    \"\"\"\n    Initializes the FmuHandlerFactory with the given path and reads the model\n    description.\n\n    Args:\n        path (str): The file path to the FMU.\n\n    Returns:\n        FmuXHandler: The appropriate FMU handler based on the FMI version.\n\n    Raises:\n        ValueError: If the FMI version is not recognized.\n    \"\"\"\n    self.path = path\n\n    # case of .py file or .py::&lt;class_name&gt;\n    if self.path.endswith(\".py\") or \"::\" in self.path:\n        self.description = ProxyModelDescription()\n    else:\n        self.description = read_model_description(path)\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuProxyHandler","title":"FmuProxyHandler","text":"<pre><code>FmuProxyHandler(path)\n</code></pre> <p>               Bases: <code>FmuXHandler</code></p> <p>A handler class that acts as a proxy for an FMU by delegating operations to a dynamically loaded proxy object. This class provides FMI-like behaviors and interfaces for interacting with the proxy. Attributes:     _proxy: The dynamically loaded proxy object.     fmu: Alias for the proxy object for compatibility with FmuXHandler.     _time (float): Internal simulation time.     description (ProxyModelDescription): A proxy model description compatible         with FmuXHandler helpers.     default_step_size (float): Default step size for the simulation.     var_name2attr (Dict[str, ProxyVarAttr]): A mapping of variable names to         their attributes.     output_var_names (List[str]): A list of output variable names. Methods:     reset():         Resets the internal simulation time to 0.0.     get_variable(name: str) -&gt; list:         Retrieves the value of a variable by name as a single-element list.     set_variables(input_dict: Dict[str, Any]):         Sets multiple variables based on the provided dictionary of         variable names and values.     step(current_time: float, step_size: float, input_dict: Dict[str, Any]) -&gt; Dict[str, Any]:         Advances the simulation by a given step size, applying inputs         before stepping and returning the output variables.     get_state() -&gt; Dict[str, Any]:         Retrieves the current state of the simulation, including time         and variable values, in a JSON-serializable format.     set_state(state: Dict[str, Any]):         Restores the simulation state from a given dictionary.</p> <p>Initialize the wrapper class with a given proxy model file path. Args:     path (str): The file path to the proxy model. This should be in the         format .py or .py::. Attributes:     _proxy: The proxy instance loaded from the file.     fmu: Alias for the proxy instance for compatibility with FmuXHandler.     _time (float): The current simulation time, initialized to 0.0.     description (ProxyModelDescription): A model description object         compatible with FmuXHandler helpers, containing metadata about         the proxy model.     default_step_size (Optional[float]): The default step size for the         simulation, extracted from the proxy model description.     var_name2attr (Dict[str, ProxyVarAttr]): A mapping of variable names         to their attributes for quick lookup.     output_var_names: A list of output variable names extracted from the         proxy model. Raises:     Any exceptions raised by <code>load_proxy_class_from_file</code> or other     operations during initialization. Source code in <code>cofmupy/wrappers.py</code> <pre><code>def __init__(self, path: str):  # pylint: disable=super-init-not-called\n    \"\"\"\n    Initialize the wrapper class with a given proxy model file path.\n    Args:\n        path (str): The file path to the proxy model. This should be in the\n            format &lt;model_name&gt;.py or &lt;model_name&gt;.py::&lt;class_name&gt;.\n    Attributes:\n        _proxy: The proxy instance loaded from the file.\n        fmu: Alias for the proxy instance for compatibility with FmuXHandler.\n        _time (float): The current simulation time, initialized to 0.0.\n        description (ProxyModelDescription): A model description object\n            compatible with FmuXHandler helpers, containing metadata about\n            the proxy model.\n        default_step_size (Optional[float]): The default step size for the\n            simulation, extracted from the proxy model description.\n        var_name2attr (Dict[str, ProxyVarAttr]): A mapping of variable names\n            to their attributes for quick lookup.\n        output_var_names: A list of output variable names extracted from the\n            proxy model.\n    Raises:\n        Any exceptions raised by `load_proxy_class_from_file` or other\n        operations during initialization.\n    \"\"\"\n    # extract proxy from path\n    self._proxy = load_proxy_class_from_file(path)()\n    self.fmu = self._proxy  # compatibility with FmuXHandler\n    self._time: float = 0.0\n\n    # Build a proxy model description compatible with FmuXHandler helpers\n    pv: List[ProxyVarAttr] = []\n    for vr, v in enumerate(self._proxy.variables()):\n        pv.append(\n            ProxyVarAttr(\n                name=v.name,\n                type=v.type,\n                causality=v.causality,\n                variability=v.variability,\n                valueReference=vr,\n                start=v.start,\n            )\n        )\n\n    self.description = ProxyModelDescription(\n        fmiVersion=\"proxy\",\n        guid=f\"proxy-{self._proxy.model_identifier}\",\n        coSimulation=ProxyCoSimulation(\n            modelIdentifier=self._proxy.model_identifier\n        ),\n        defaultExperiment=ProxyDefaultExperiment(\n            stepSize=self._proxy.default_step_size\n        ),\n        modelVariables=pv,\n    )\n\n    self.default_step_size = (\n        self.description.defaultExperiment.stepSize\n        if self.description.defaultExperiment\n        else None\n    )\n\n    self.var_name2attr: Dict[str, ProxyVarAttr] = {\n        v.name: v for v in self.description.modelVariables\n    }\n    self.output_var_names = self.get_output_names()\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler","title":"FmuXHandler","text":"<pre><code>FmuXHandler(path, fmu_slave)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for handling FMU Slave objects (FMI 2.0 or FMI 3.0).</p> ATTRIBUTE DESCRIPTION <code>description</code> <p>The model description of the FMU.</p> <p> TYPE: <code>ModelDescription</code> </p> <code>var_name2attr</code> <p>A dictionary mapping variable names to their attributes.</p> <p> TYPE: <code>dict</code> </p> <code>fmu</code> <p>The FMU instance.</p> <p> TYPE: <code>FMU</code> </p> <code>output_var_names</code> <p>A list of output variable names.</p> <p> TYPE: <code>list</code> </p> METHOD DESCRIPTION <code>reset</code> <p>Abstract method to reset the FMU. Must be implemented by subclasses.</p> <code>step</code> <p>Abstract method to perform a simulation step. Must be implemented by     subclasses.</p> <code>cancel_step</code> <p>Cancels the current step of the FMU.</p> <code>get_state</code> <p>Retrieves the current state of the FMU.</p> <code>set_state</code> <p>Sets the state of the FMU to the given state.</p> <code>get_output_names</code> <p>Retrieves the names of the FMU output variables.</p> <code>get_input_names</code> <p>Retrieves the names of the FMU input variables.</p> <code>get_parameter_names</code> <p>Retrieves the names of the FMU tunable parameters.</p> <p>Initializes the FMU handler with the given path and FMU slave class.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path of .fmu file to open</p> <p> TYPE: <code>str</code> </p> <code>fmu_slave</code> <p>The FMU slave class of FMPy to use to open the fmu</p> <p> TYPE: <code>class</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def __init__(self, path: str, fmu_slave):\n    \"\"\"Initializes the FMU handler with the given path and FMU slave class.\n\n    Args:\n        path (str): The path of .fmu file to open\n        fmu_slave (class): The FMU slave class of FMPy to use to open the fmu\n    \"\"\"\n    # read the model description\n    self.description = read_model_description(path)\n\n    self.default_step_size = (\n        self.description.defaultExperiment.stepSize\n        if self.description.defaultExperiment\n        else None\n    )\n\n    # Create a dictionary to map variable names to attributes\n    self.var_name2attr = {}\n    for variable in self.description.modelVariables:\n        self.var_name2attr[variable.name] = variable\n\n    # extract the FMU and instantiate the slave\n    unzipdir = extract(path)\n    fmu_name = os.path.basename(path)\n\n    self.fmu = fmu_slave(\n        guid=self.description.guid,\n        unzipDirectory=unzipdir,\n        modelIdentifier=self.description.coSimulation.modelIdentifier,\n        instanceName=fmu_name,\n    )\n\n    # Get the output variable names\n    self.output_var_names = []\n    self.output_var_names = list(self.get_output_names())\n\n    # Instantiate the FMU\n    self.fmu.instantiate(loggingOn=False)\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.cancel_step","title":"cancel_step","text":"<pre><code>cancel_step()\n</code></pre> <p>Cancels the current step of the FMU.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def cancel_step(self):\n    \"\"\"Cancels the current step of the FMU.\"\"\"\n    self.fmu.cancelStep()\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_causality","title":"get_causality","text":"<pre><code>get_causality(name)\n</code></pre> <p>Retrieves the causality of a variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable to get</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The causality of the variable</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_causality(self, name: str) -&gt; str:\n    \"\"\"Retrieves the causality of a variable.\n\n    Args:\n        name (str): The name of the variable to get\n\n    Returns:\n        str: The causality of the variable\n    \"\"\"\n    return self.var_name2attr[name].causality\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_input_names","title":"get_input_names","text":"<pre><code>get_input_names()\n</code></pre> <p>Retrieves the list of names of the FMU's input variables.</p> RETURNS DESCRIPTION <code>list</code> <p>A list containing the name of each input variable</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_input_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the list of names of the FMU's input variables.\n\n    Returns:\n        list: A list containing the name of each input variable\n    \"\"\"\n    input_names = []\n    for variable in self.description.modelVariables:\n        if variable.causality == \"input\":\n            input_names.append(variable.name)\n    return input_names\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_output_names","title":"get_output_names","text":"<pre><code>get_output_names()\n</code></pre> <p>Retrieves the list of names of the FMU's output variables.</p> RETURNS DESCRIPTION <code>list</code> <p>A list containing the name of each output variable</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_output_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the list of names of the FMU's output variables.\n\n    Returns:\n        list: A list containing the name of each output variable\n    \"\"\"\n    output_names = []\n    for variable in self.description.modelVariables:\n        if variable.causality == \"output\":\n            output_names.append(variable.name)\n    return output_names\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_parameter_names","title":"get_parameter_names","text":"<pre><code>get_parameter_names()\n</code></pre> <p>Retrieves the names of the FMU tunable parameters. Returns:     list: A list containing the name of each tunable parameter</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_parameter_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the names of the FMU tunable parameters.\n    Returns:\n        list: A list containing the name of each tunable parameter\n    \"\"\"\n    parameter_names = []\n    for variable in self.description.modelVariables:\n        if variable.causality == \"parameter\":\n            parameter_names.append(variable.name)\n    return parameter_names\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_state","title":"get_state","text":"<pre><code>get_state()\n</code></pre> <p>Retrieves the current state of the FMU.</p> RETURNS DESCRIPTION <code>fmiXFMUState</code> <p>The current of state of the FMU, X is the version of FMI used (ie. fmi3FMUState for FMI3.0)</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_state(self):\n    \"\"\"Retrieves the current state of the FMU.\n\n    Returns:\n        (fmiXFMUState): The current of state of the FMU, X is the version of FMI used\n            (ie. fmi3FMUState for FMI3.0)\n    \"\"\"\n    return self.fmu.getFMUState()\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_variable","title":"get_variable","text":"<pre><code>get_variable(name)\n</code></pre> <p>Gets the variable matching the given name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable to get</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list</code> <p>The value of the variable, as a list.</p> <p> TYPE: <code>list</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_variable(self, name: str) -&gt; list:\n    \"\"\"\n    Gets the variable matching the given name.\n\n    Args:\n        name (str): The name of the variable to get\n\n    Returns:\n        list: The value of the variable, as a list.\n    \"\"\"\n    var = self.var_name2attr[name]\n    return getattr(self.fmu, f\"get{var.type}\")([var.valueReference])\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_variable_names","title":"get_variable_names","text":"<pre><code>get_variable_names()\n</code></pre> <p>Retrieves the names of all variables in the FMU.</p> RETURNS DESCRIPTION <code>list</code> <p>A list containing the name of each variable</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_variable_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the names of all variables in the FMU.\n\n    Returns:\n        list: A list containing the name of each variable\n    \"\"\"\n    return [variable.name for variable in self.description.modelVariables]\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_variable_type","title":"get_variable_type","text":"<pre><code>get_variable_type(name)\n</code></pre> <p>Retrieves the type of the variable with the given name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The type of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_variable_type(self, name: str) -&gt; str:\n    \"\"\"Retrieves the type of the variable with the given name.\n\n    Args:\n        name (str): The name of the variable.\n\n    Returns:\n        str: The type of the variable.\n    \"\"\"\n    return self.var_name2attr[name].type\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.get_variables","title":"get_variables","text":"<pre><code>get_variables(names)\n</code></pre> <p>Gets the values of the FMU variables matching the given names.</p> PARAMETER DESCRIPTION <code>names</code> <p>A list of variable names to get</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the variable names and their corresponding   values</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def get_variables(self, names: list[str]) -&gt; dict:\n    \"\"\"Gets the values of the FMU variables matching the given names.\n\n    Args:\n        names (list): A list of variable names to get\n\n    Returns:\n        dict: A dictionary containing the variable names and their corresponding\n              values\n    \"\"\"\n    return {name: self.get_variable(name) for name in names}\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.reset","title":"reset  <code>abstractmethod</code>","text":"<pre><code>reset()\n</code></pre> <p>Resets the FMU to its initial state and sets up the experiment.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>@abstractmethod\ndef reset(self):\n    \"\"\"Resets the FMU to its initial state and sets up the experiment.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.set_state","title":"set_state","text":"<pre><code>set_state(state)\n</code></pre> <p>Sets the state of the FMU to the given state.</p> PARAMETER DESCRIPTION <code>state</code> <p>The state of the FMU to set, X is the version of FMI used (ie. fmi3FMUState for FMI3.0)</p> <p> TYPE: <code>fmiXFMUState</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def set_state(self, state):\n    \"\"\"Sets the state of the FMU to the given state.\n\n    Args:\n        state (fmiXFMUState): The state of the FMU to set, X is the version of FMI\n            used (ie. fmi3FMUState for FMI3.0)\n    \"\"\"\n    self.fmu.setFMUState(state)\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.set_variables","title":"set_variables","text":"<pre><code>set_variables(input_dict)\n</code></pre> <p>Sets the FMU variables to the given values.</p> PARAMETER DESCRIPTION <code>input_dict</code> <p>A dictionary containing variable names and their corresponding values.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>def set_variables(self, input_dict: dict):\n    \"\"\"Sets the FMU variables to the given values.\n\n    Args:\n        input_dict (dict): A dictionary containing variable names and their\n            corresponding values.\n    \"\"\"\n    for name, value in input_dict.items():\n        self._set_variable(name, value)\n</code></pre>"},{"location":"api/wrappers/#cofmupy.wrappers.FmuXHandler.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(current_time, step_size, input_dict)\n</code></pre> <p>Performs a simulation step with the given current time, step size, and input values.</p> Source code in <code>cofmupy/wrappers.py</code> <pre><code>@abstractmethod\ndef step(self, current_time, step_size, input_dict):\n    \"\"\"\n    Performs a simulation step with the given current time, step size, and input\n    values.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"generated/gallery/","title":"Examples","text":"<p>This section contains examples to illustrate the use of CoFmuPy.</p> <p>First, general examples demonstrate how to configure and run CoFmuPy on toy cases. More low level features are also explained.</p> <p>Second, academic examples illustrate how to apply CoFmuPy on well-known systems, such as the Bouncing Ball.</p>"},{"location":"generated/gallery/#general-examples","title":"General examples","text":"<p> A first example: an AC voltage source and a resistor </p> <p> A follow-up example: mixing an FMU with a Python proxy FMU </p>"},{"location":"generated/gallery/#academic-fmu-examples","title":"Academic FMU examples","text":"<p>This section gathers examples of well-known systems that are used in academic contexts, such as the Bouncing Ball, the Dual Mass Oscillator, etc.</p> <p> The \"Bouncing Ball\" </p> <p> The \"Dual Mass Oscillator\" </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:06.450 total execution time for generated_gallery files:</p> <p>+----------------------------------------------------------------------------------------+-----------+--------+ | plot_00_get_started (docs/examples/plot_00_get_started.py) | 00:03.938 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+ | plot_01_fmu_proxy (docs/examples/plot_01_fmu_proxy.py)       | 00:02.511 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/plot_00_get_started/","title":"A first example: an AC voltage source and a resistor","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_00_get_started/#a-first-example-an-ac-voltage-source-and-a-resistor","title":"A first example: an AC voltage source and a resistor","text":"<p>This is a simple example of how to use CoFmuPy to load a co-simulation system (JSON configuration file and FMUs) and run the simulation.</p> <p>The use case is a simple system with an AC voltage source and a resistor. The AC voltage source generates a sinusoidal voltage signal, and the resistor consumes the power from the source. The resistor has a variable resistance that can be changed during the simulation.</p> <p></p> <p>We will first download all necessary resources such as the FMUs (source and resistor) and the configuration file from the public link provided below.</p> <pre><code>import os\nimport urllib.request\nimport zipfile\n\nurl = \"https://share-is.pf.irt-saintexupery.com/s/HSNSeteJPoJjyXx/download\"\n\n# Local path to resources folder\nresources_path = \"example1.zip\"\n\n# Download and unzip the file\nurllib.request.urlretrieve(url, resources_path)\nwith zipfile.ZipFile(resources_path, \"r\") as zip_ref:\n    zip_ref.extractall(\".\")\n\n# Remove the zip file\nos.remove(resources_path)\n\nprint(\"Resources unzipped in example1 folder!\")\n</code></pre> <p>Out:</p> <pre><code>Resources unzipped in example1 folder!\n</code></pre> <p>Now that we have all the necessary resources, we can start the example.</p> <p>The base object in CoFmuPy is the Coordinator. It manages all the components of CoFmuPy: the Master algorithm, the graph engine, the data stream handlers, etc. In this tutorial, we only deal with the Coordinator that communicates automatically with the different components.</p> <p>We will first import the Coordinator object from CoFmuPy and create an instance of it.</p> <pre><code>from cofmupy import Coordinator\n\ncoordinator = Coordinator()\n</code></pre>"},{"location":"generated/gallery/plot_00_get_started/#the-json-configuration-file","title":"The JSON configuration file","text":"<p>The first step is to create the JSON configuration file based on your simulation system. This file must contain the information about the FMUs, the connections between them, and the simulation settings. For more information, check the page on how to create a JSON configuration file, see this page. The system also requires input data to run the simulation (here, the variable resistor from a CSV file).</p> <p>Here is the content of the configuration file for this example:</p> <pre><code>config_path = \"example1/config_with_csv.json\"\nwith open(config_path, \"r\") as f:\n    print(f.read())\n</code></pre> <p>Out:</p> <pre><code>{\n  \"fmus\": [\n    {\n      \"id\": \"source\",\n      \"path\": \"example1/source.fmu\",\n      \"supplier\": \"IRT Saint Exup\u00e9ry\"\n    },\n    {\n      \"id\": \"resistor\",\n      \"path\": \"example1/resistor.fmu\",\n      \"initialization\": {\n        \"R\": 0.5\n      },\n      \"supplier\": \"IRT Saint Exup\u00e9ry\"\n    }\n  ],\n  \"connections\": [\n    {\n      \"source\": {\n        \"id\": \"source\",\n        \"variable\": \"V\",\n        \"unit\": \"V\"\n      },\n      \"target\": {\n        \"id\": \"resistor\",\n        \"variable\": \"V\",\n        \"unit\": \"V\"\n      }\n    },\n    {\n      \"source\": {\n        \"type\": \"csv\",\n        \"path\": \"example1/resistor.csv\",\n        \"variable\": \"R\",\n        \"unit\": \"Ohm\",\n        \"interpolation\": \"previous\"\n      },\n      \"target\": {\n        \"id\": \"resistor\",\n        \"variable\": \"R\",\n        \"unit\": \"Ohm\"\n      }\n    }\n  ],\n  \"cosim_method\": \"jacobi\",\n  \"edge_sep\": \" -&gt; \"\n}\n</code></pre> <p>In the JSON configuration file, you can see the following information:</p> <ul> <li>The 2 FMUs used in the system: an AC voltage source and a resistor</li> <li>2 connections:<ul> <li>the output of the source is connected to the input of the resistor</li> <li>the resistance value of the resistor is set by a CSV file</li> </ul> </li> <li>The simulation settings: the cosimulation method and the edge separator (used in the graph   visualization).</li> </ul> <p>The next step is to load the configuration file via the Coordinator. This will start the multiple components to handle the whole simulation process:</p> <ul> <li>the Master: the main process that controls the co-simulation</li> <li>the data stream handlers: the objects that read and write data from/to the system</li> <li>the graph engine</li> </ul> <pre><code>coordinator.start(config_path)\n</code></pre> <p>Out:</p> <pre><code>Unknown property is ignore : supplier\nUnknown property is ignore : supplier\nUnknown property is ignore : unit\ntarget is not a list\nSkipping Fixed Point Initialization\n</code></pre> <p>You can access the attributes of the components of the Coordinator object. For example, you can access the co-simulation method via the <code>master.cosim_method</code> attribute.</p> <pre><code># We can check the list of FMUs in the Master or the cosimulation method used\nprint(\"FMUs in Master:\", list(coordinator.master.fmu_handlers.keys()))\nprint(f\"Cosimulation method: {coordinator.master.cosim_method}\")\n\n# ... and the stream handlers (here, the CSV source). Keys are (fmu_name, var_name)\nprint(\"\\nCSV data stream handler key:\", coordinator.stream_handlers[0])\n\ncsv_data_handler = coordinator.stream_handlers[0]\nprint(\"CSV path for resistance value R:\", csv_data_handler.path)\nprint(\"CSV data for R (as Pandas dataframe):\\n\", csv_data_handler.data.head())\n</code></pre> <p>Out:</p> <pre><code>FMUs in Master: ['source', 'resistor']\nCosimulation method: jacobi\n\nCSV data stream handler key: &lt;cofmupy.data_stream_handler.csv_data_stream_handler.CsvDataStreamHandler object at 0x7f14f9e39e20&gt;\nCSV path for resistance value R: example1/resistor.csv\nCSV data for R (as Pandas dataframe):\n       t    R\n0  0.00  1.0\n1  0.42  1.5\n</code></pre> <p>You can also visualize the graph of the system using the <code>plot_graph</code> method. This method will plot the connections between the FMUs in the system.</p> <pre><code>coordinator.graph_engine.plot_graph()\n</code></pre>"},{"location":"generated/gallery/plot_00_get_started/#running-the-simulation","title":"Running the simulation","text":"<p>After loading the configuration file, you can run the simulation by calling the <code>do_step</code> method. This method will run the simulation for a given time step via the Master algorithm.</p> <p>The <code>do_step</code> method will save the results in the data storages defined in the configuration file. You can access the data storages using the <code>data_storages</code> attribute of the Coordinator object. By default, a data storage for all outputs is created in the \"storage/results.csv\" file (see below).</p> <pre><code>print(f\"Current time of the co-simulation: {coordinator.master.current_time}\")\n\ntime_step = 0.01\ncoordinator.do_step(time_step)\n\nprint(\n    \"Current time of the co-simulation after one step: \"\n    f\"{coordinator.master.current_time}\"\n)\n\n# Run N steps\nN = 100\nfor _ in range(N):\n    coordinator.do_step(time_step)\n\nprint(\n    f\"Current time of the co-simulation after {N+1} steps: \"\n    f\"{coordinator.master.current_time:.2f}\"\n)\n</code></pre> <p>Out:</p> <pre><code>Current time of the co-simulation: 0.0\nCurrent time of the co-simulation after one step: 0.01\nCurrent time of the co-simulation after 101 steps: 1.01\n</code></pre> <p>It is possible to run the simulation until a specific end time by using the <code>run_simulation</code> method. This method will run the simulation until the end time and return the results of the simulation. Note that you should recreate a new Coordinator from scratch. It is not possible to mix both <code>do_step</code> and <code>run_simulation</code> methods in the same Coordinator object.</p> <p>At the end of the simulation, you can also manually save results to a CSV file:</p> <pre><code>coordinator.save_results(\"simulation_results.csv\")\n</code></pre>"},{"location":"generated/gallery/plot_00_get_started/#visualizing-the-results","title":"Visualizing the results","text":"<p>Results can be accessible directly in the Master object or in the CSV file we just saved.</p> <pre><code>import pandas as pd\n\nresults = pd.read_csv(\"simulation_results.csv\")\nprint(results.head(10))\n</code></pre> <p>Out:</p> <pre><code>   time  resistor.I   source.V\n0  0.00    0.000000   0.000000\n1  0.01    1.255810   1.255810\n2  0.02    2.506665   2.506665\n3  0.03    3.747626   3.747626\n4  0.04    4.973798   4.973798\n5  0.05    6.180340   6.180340\n6  0.06    7.362491   7.362491\n7  0.07    8.515586   8.515586\n8  0.08    9.635073   9.635073\n9  0.09   10.716536  10.716536\n</code></pre> <pre><code>results.plot(x=\"time\", grid=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;Axes: xlabel='time'&gt;\n</code></pre> <p>We can observe that the change of resistance value at t = 0.42s effectively changes the current \\(I = U/R\\) flowing through the resistor.</p> <p>Total running time of the script: ( 0 minutes  3.938 seconds)</p> <p> Download Python source code: plot_00_get_started.py</p> <p> Download Jupyter notebook: plot_00_get_started.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/plot_01_fmu_proxy/","title":"A follow-up example: mixing an FMU with a Python proxy FMU","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_01_fmu_proxy/#a-follow-up-example-mixing-an-fmu-with-a-python-proxy-fmu","title":"A follow-up example: mixing an FMU with a Python proxy FMU","text":"<p>This tutorial is a continuation of the \"A first example: an AC voltage source and a resistor\". The goal here is to show how CoFmuPy allows you to mix compiled FMUs and Python proxy FMUs (<code>fmuproxy</code>) in the same co-simulation.</p> <ul> <li>The AC voltage source is provided as a compiled FMU (<code>source.fmu</code>)</li> <li>The resistor is defined as a Python proxy FMU (<code>resistor.py</code>)</li> </ul> <p>This setup illustrates a common workflow: you can rapidly prototype some parts of your system in Python (for example to test an AI model or a simple block), while keeping others as standard FMUs.</p>"},{"location":"generated/gallery/plot_01_fmu_proxy/#downloading-and-preparing-resources","title":"Downloading and preparing resources","text":"<p>As before, we first download the resources (the FMU and the Python proxy file) from a shared repository and unzip them locally.</p> <pre><code>import os\nimport urllib.request\nimport zipfile\n\nurl = \"https://share-is.pf.irt-saintexupery.com/s/HSNSeteJPoJjyXx/download\"\nresources_path = \"example1.zip\"\n\nurllib.request.urlretrieve(url, resources_path)\nwith zipfile.ZipFile(resources_path, \"r\") as zip_ref:\n    zip_ref.extractall(\".\")\nos.remove(resources_path)\n\nprint(\"Resources unzipped in example1 folder!\")\n</code></pre> <p>Out:</p> <pre><code>Resources unzipped in example1 folder!\n</code></pre>"},{"location":"generated/gallery/plot_01_fmu_proxy/#creating-the-coordinator","title":"Creating the Coordinator","text":"<p>As in the previous tutorial, the base object is the <code>Coordinator</code>. It manages the master algorithm, the FMUs, the proxies, the data handlers, etc.</p> <pre><code>from cofmupy import Coordinator\n\ncoordinator = Coordinator()\n</code></pre>"},{"location":"generated/gallery/plot_01_fmu_proxy/#the-json-configuration-file","title":"The JSON configuration file","text":"<p>The configuration file describes the system: - one FMU (<code>source.fmu</code>) for the AC voltage source - one Python proxy (<code>resistor.py</code>) implementing a resistor - the connection between the source output and the resistor input</p> <p>Let\u2019s open the configuration file to inspect it.</p> <pre><code>config_path = \"example1/config_with_fmu_proxy.json\"\nwith open(config_path, \"r\") as f:\n    print(f.read())\n</code></pre> <p>Out:</p> <pre><code>{\n    \"fmus\": [\n        {\n            \"id\": \"source\",\n            \"path\": \"example1/source.fmu\",\n            \"supplier\": \"IRT Saint Exup\u00e9ry\"\n        },\n        {\n            \"id\": \"resistor\",\n            \"path\": \"example1/resistor.py::Resistor\",\n            \"initialization\": {\n                \"R\": 0.5\n            },\n            \"supplier\": \"IRT Saint Exup\u00e9ry\"\n        }\n    ],\n    \"connections\": [\n        {\n            \"source\": {\n                \"id\": \"source\",\n                \"variable\": \"V\",\n                \"unit\": \"V\"\n            },\n            \"target\": {\n                \"id\": \"resistor\",\n                \"variable\": \"V\",\n                \"unit\": \"V\"\n            }\n        },\n        {\n            \"source\": {\n                \"type\": \"csv\",\n                \"path\": \"example1/resistor.csv\",\n                \"variable\": \"R\",\n                \"unit\": \"Ohm\",\n                \"interpolation\": \"previous\"\n            },\n            \"target\": {\n                \"id\": \"resistor\",\n                \"variable\": \"R\",\n                \"unit\": \"Ohm\"\n            }\n        }\n    ],\n    \"cosim_method\": \"jacobi\",\n    \"edge_sep\": \" -&gt; \"\n}\n</code></pre>"},{"location":"generated/gallery/plot_01_fmu_proxy/#starting-the-simulation-system","title":"Starting the simulation system","text":"<p>The coordinator loads the FMUs and proxies, starts the services, and prepares the simulation.</p> <pre><code>coordinator.start(config_path)\n</code></pre> <p>Out:</p> <pre><code>Unknown property is ignore : supplier\nUnknown property is ignore : supplier\nUnknown property is ignore : unit\ntarget is not a list\n============ Resistor =============\nSkipping Fixed Point Initialization\n</code></pre> <p>Once loaded, we can inspect the FMUs/proxies and the cosimulation method used.</p> <pre><code>print(\"FMUs and proxies in Master:\", list(coordinator.master.fmu_handlers.keys()))\nprint(f\"Cosimulation method: {coordinator.master.cosim_method}\")\n</code></pre> <p>Out:</p> <pre><code>FMUs and proxies in Master: ['source', 'resistor']\nCosimulation method: jacobi\n</code></pre>"},{"location":"generated/gallery/plot_01_fmu_proxy/#running-the-simulation-step-by-step","title":"Running the simulation step by step","text":"<p>Just like before, we can step through the simulation manually.</p> <pre><code>print(f\"Initial simulation time: {coordinator.master.current_time}\")\n\ntime_step = 0.01\ncoordinator.do_step(time_step)\n\nprint(f\"Simulation time after one step: {coordinator.master.current_time}\")\n\n# Run N steps\nN = 100\nfor _ in range(N):\n    coordinator.do_step(time_step)\n\nprint(f\"Simulation time after {N+1} steps: {coordinator.master.current_time:.2f}\")\n</code></pre> <p>Out:</p> <pre><code>Initial simulation time: 0.0\nSimulation time after one step: 0.01\nSimulation time after 101 steps: 1.01\n</code></pre>"},{"location":"generated/gallery/plot_01_fmu_proxy/#running-the-full-simulation","title":"Running the full simulation","text":"<p>Alternatively, we can run until a specific end time in one command.</p> <pre><code>coordinator.save_results(\"simulation_results.csv\")\n</code></pre>"},{"location":"generated/gallery/plot_01_fmu_proxy/#visualizing-results","title":"Visualizing results","text":"<p>Results are stored in a CSV file. We can load them into pandas and plot.</p> <pre><code>import pandas as pd\n\nresults = pd.read_csv(\"simulation_results.csv\")\nprint(results.head(10))\n# Results can be accessible directly in the Master object or in the CSV file we just\n# saved.\n</code></pre> <p>Out:</p> <pre><code>   time  resistor.I   source.V\n0  0.00    0.000000   0.000000\n1  0.01    1.255810   1.255810\n2  0.02    2.506665   2.506665\n3  0.03    3.747626   3.747626\n4  0.04    4.973798   4.973798\n5  0.05    6.180340   6.180340\n6  0.06    7.362491   7.362491\n7  0.07    8.515586   8.515586\n8  0.08    9.635073   9.635073\n9  0.09   10.716536  10.716536\n</code></pre> <pre><code>results.plot(x=\"time\", grid=True)\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;Axes: xlabel='time'&gt;\n</code></pre>"},{"location":"generated/gallery/plot_01_fmu_proxy/#conclusion","title":"Conclusion","text":"<p>This example shows how easy it is to integrate a Python proxy FMU (<code>fmuproxy</code>) alongside compiled FMUs in CoFmuPy.</p> <p>This workflow is ideal when: - you want to test new logic (e.g., AI model) quickly in Python - you don\u2019t want to package everything as an FMU yet - you still need interoperability with other FMUs</p> <p>Later, the Python proxy can be exported as a true FMU (using <code>PythonFMU</code> for example), making the system fully portable across different tools.</p> <p>Total running time of the script: ( 0 minutes  2.511 seconds)</p> <p> Download Python source code: plot_01_fmu_proxy.py</p> <p> Download Jupyter notebook: plot_01_fmu_proxy.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/academic_examples/mg_execution_times/","title":"Computation times","text":"<p>00:01.338 total execution time for generated_gallery_academic_examples files:</p> <p>+-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_01_dual_mass_oscillator (docs/examples/academic_examples/plot_01_dual_mass_oscillator.py) | 00:01.032 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+ | plot_00_bouncing_ball (docs/examples/academic_examples/plot_00_bouncing_ball.py)                      | 00:00.306 | 0.0 MB | +-------------------------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/academic_examples/plot_00_bouncing_ball/","title":"The \"Bouncing Ball\"","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/academic_examples/plot_00_bouncing_ball/#the-bouncing-ball","title":"The \"Bouncing Ball\"","text":"<p>This example demonstrates how to use CoFmuPy to run the famous Bouncing Ball example. The FMU simulates a ball bouncing on the ground.</p>"},{"location":"generated/gallery/academic_examples/plot_00_bouncing_ball/#the-original-bouncing-ball-example","title":"The original bouncing ball example","text":"<p>We will load and run the simulation of the Bouncing Ball FMU.</p> <p>First, let's define the configuration for the Bouncing Ball system. Instead of using a JSON file, we will directly create the configuration in a Python dictionary.</p> <pre><code>from cofmupy import Coordinator\n\n# We define a simple CoFmuPy config dictionary with a single FMU and no connection\nconfig = {\n    \"fmus\": [\n        {\"id\": \"bouncing_ball\", \"path\": \"../../../resources/fmus/BouncingBall.fmu\"}\n    ],\n    \"connections\": []\n}\n\n# We create a Coordinator object and start it with the config dictionary\ncoordinator = Coordinator()\ncoordinator.start(config)\n\n# Let's check the default value of the coefficient of restitution `e` in the FMU.\n# A variable in CoFmuPy is identified by a tuple (fmu_id, variable_name).\ne = coordinator.get_variable((\"bouncing_ball\", \"e\"))\nprint(\"Default value of coefficient of restitution 'e' (from the FMU):\", e)\n</code></pre> <p>Out:</p> <pre><code>Skipping Fixed Point Initialization\nDefault value of coefficient of restitution 'e' (from the FMU): [0.7]\n</code></pre> <p>We now run the simulation for 2.8 seconds with a 10 ms time step. We retrieve the results and plot the height of the ball over time.</p> <pre><code>step_size = 0.01  # 10 ms time step\nend_time = 2.8  # Simulation time in seconds\n\ncoordinator.run_simulation(step_size, end_time)\nresults = coordinator.get_results()\n\n# The results is a dictionary with the time and the values of the variables.\nprint(\"Results keys:\", results.keys())\n</code></pre> <p>Out:</p> <pre><code>Results keys: dict_keys(['time', ('bouncing_ball', 'h'), ('bouncing_ball', 'v')])\n</code></pre> <pre><code>import matplotlib.pyplot as plt\n\n\ndef plot_height(results):\n    plt.plot(results[\"time\"], results[(\"bouncing_ball\", \"h\")])\n    plt.grid()\n    plt.title(\"Bouncing Ball Height over time\")\n    plt.xlabel(\"Time [s]\")\n    plt.ylabel(\"Height [m]\")\n\n\nplot_height(results)\n</code></pre> <p></p>"},{"location":"generated/gallery/academic_examples/plot_00_bouncing_ball/#variable-initialization","title":"Variable initialization","text":"<p>We will now see how to set the initial values of the FMU variables. First, let's look at the variables in the Bouncing Ball FMU and their causality.</p> <pre><code>variables = coordinator.get_variable_names()\nprint(\"Variables in the Bouncing Ball FMU (and their causality):\")\nfor var in variables:\n    print(f\"- '{var[1]}': {coordinator.get_causality(var)}\")\n</code></pre> <p>Out:</p> <pre><code>Variables in the Bouncing Ball FMU (and their causality):\n- 'time': independent\n- 'h': output\n- 'der(h)': local\n- 'v': output\n- 'der(v)': local\n- 'g': parameter\n- 'e': parameter\n- 'v_min': local\n</code></pre> <p>In the following, we will set the coefficient of restitution <code>e</code> to 0.5, meaning that the ball will bounce less high than in the reference simulation.</p> <p>The initialization of the FMU variables is done in the configuration file (or in the dictionary here). The <code>initialization</code> key is used to set the initial values of the FMU variables. The values are set before the simulation starts.</p> <pre><code>config = {\n    \"fmus\": [\n        {\n            \"id\": \"bouncing_ball\",\n            \"path\": \"../../../resources/fmus/BouncingBall.fmu\",\n            \"initialization\": {\"e\": 0.5},  # Set initial value\n        }\n    ]\n}\n\ncoordinator = Coordinator()\ncoordinator.start(config)\n\ncoordinator.run_simulation(step_size, end_time)\n\nresults = coordinator.get_results()\nplot_height(results)\n</code></pre> <p></p> <p>Out:</p> <pre><code>Skipping Fixed Point Initialization\n</code></pre> <p>We can also set the initial height <code>h</code> of the ball to 5 meters. <code>h</code> is an output variable but its start value can be set at initialization of the FMU.</p> <pre><code>config = {\n    \"fmus\": [\n        {\n            \"id\": \"bouncing_ball\",\n            \"path\": \"../../../resources/fmus/BouncingBall.fmu\",\n            \"initialization\": {\"e\": 0.5, \"h\": 5},\n        }\n    ],\n    \"connections\": []\n}\n\ncoordinator = Coordinator()\ncoordinator.start(config)\n\ncoordinator.run_simulation(step_size, end_time)\n\nresults = coordinator.get_results()\nplot_height(results)\n</code></pre> <p></p> <p>Out:</p> <pre><code>Skipping Fixed Point Initialization\n</code></pre>"},{"location":"generated/gallery/academic_examples/plot_00_bouncing_ball/#comparison-with-the-analytical-solution","title":"Comparison with the analytical solution","text":"<p>To validate the simulation with CoFmuPy, we compare the results with the analytical solution of the bouncing ball model as defined in the reference FMU.</p> <pre><code>import numpy as np\n\n\ndef analytical_solution(time_points, e=0.8, h0=1.0):\n    \"\"\"Calculate the height of the bouncing ball at time t using the analytical\n    solution.\n    \"\"\"\n    g = 9.81\n\n    # Time and velocity of the fictive first bounce (negative because before t=0)\n    t_bounce = -np.sqrt(2 * h0 / g)\n    v_bounce = -t_bounce * g\n\n    h = np.zeros_like(time_points)\n    for i, t in enumerate(time_points):\n        dt = t - t_bounce  # Time since last bounce\n        h[i] = v_bounce * dt - 0.5 * g * dt**2  # Height as a parabolic flight\n        if h[i] &lt; 0:\n            h[i] = 0\n            t_bounce = t\n            v_bounce = e * v_bounce\n    return h\n</code></pre> <pre><code># Calculate the analytical solution\ntime_points = np.linspace(0, end_time, 1000)\nanalytical_heights = analytical_solution(time_points, e=0.5, h0=5)\n\n# Plot the results and the analytical solution\nplot_height(results)\nplt.plot(\n    time_points - step_size,\n    analytical_heights,\n    label=\"Analytical Solution\",\n    linestyle=\"--\",\n    color=\"orange\",\n)\nplt.title(\"Bouncing Ball Height: CoFmuPy simulation vs Analytical solution\")\nplt.legend([\"CoFmuPy simulation\", \"Analytical solution\"])\n</code></pre> <p></p> <p>Out:</p> <pre><code>&lt;matplotlib.legend.Legend object at 0x7f14f79da780&gt;\n</code></pre>"},{"location":"generated/gallery/academic_examples/plot_00_bouncing_ball/#conclusion","title":"Conclusion","text":"<p>In this example, we have seen how to use CoFmuPy to run the Bouncing Ball FMU. We have learnt how to:</p> <ul> <li>Load the FMU and run a simulation</li> <li>Retrieve and plot the results</li> <li>Modify the initial values of the FMU variables</li> </ul> <p>Total running time of the script: ( 0 minutes  0.306 seconds)</p> <p> Download Python source code: plot_00_bouncing_ball.py</p> <p> Download Jupyter notebook: plot_00_bouncing_ball.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/academic_examples/plot_01_dual_mass_oscillator/","title":"The \"Dual Mass Oscillator\"","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/academic_examples/plot_01_dual_mass_oscillator/#the-dual-mass-oscillator","title":"The \"Dual Mass Oscillator\"","text":"<p>This example demonstrates how to use CoFmuPy to run the well-known Dual Mass Oscillator example. The system simulates two masses connected with three springs and dampers on two walls.</p> <p>The system is composed of two FMUs that are connected together. After describing the FMUs and the connections between them, we will run the simulation and plot the results.</p> <p>The FMUs are provided by OpenModelica and are available in the OMSimulator Github repo.</p> <p>Warning</p> <p>The FMUs are currently not working on Windows OS. We recommend using a Linux system to run this example.</p>"},{"location":"generated/gallery/academic_examples/plot_01_dual_mass_oscillator/#description-of-the-system","title":"Description of the system","text":"<p>The Dual Mass Oscillator is a mechanical system composed of two masses, each connected to a wall by a spring and a damper. The first mass is connected to the second mass by a third spring/damper. Two FMUs are used to model the system:</p> <ul> <li><code>DualMassOscillator.System1</code>: This FMU models the first mass and the spring   connected to the left wall. It takes as input the force <code>F</code> that the second spring   applies on the first mass. It outputs the position <code>x1</code>, velocity <code>v1</code>, and   acceleration <code>a1</code> of the first mass.</li> <li><code>DualMassOscillator.System2</code>: This FMU models the second mass and the two other   springs/dampers (the one connected to the right wall and the one connecting the two   masses). It takes as input the position <code>x1</code>, velocity <code>v1</code>, and acceleration <code>a1</code>   of the first mass. It outputs the force <code>F</code> that the second spring applies on the   first mass.</li> </ul> <p>The two FMUs are connected together with bidirectional connections (creating an algebraic loop).</p>"},{"location":"generated/gallery/academic_examples/plot_01_dual_mass_oscillator/#the-configuration","title":"The configuration","text":"<p>First, let's define the configuration that describes the Dual Mass Oscillator system. Instead of using a JSON file, we will directly create the configuration in a Python dictionary for better readability.</p> <p>We first define the FMUs involved in the system. We can set initial values.</p> <pre><code>fmus = [\n    {\n        \"id\": \"mass1\",\n        \"path\": \"../../../resources/fmus/DualMassOscillator.System1.fmu\",\n        \"initialization\": {\"m1\": 1.0, \"k1\": 10.0, \"c1\": 0.2, \"x1_start\": 0.0},\n    },\n    {\n        \"id\": \"mass2\",\n        \"path\": \"../../../resources/fmus/DualMassOscillator.System2.fmu\",\n        \"initialization\": {\n            \"m2\": 1.0,\n            \"k2\": 10.0,\n            \"c2\": 0.5,\n            \"k3\": 20.0,\n            \"c3\": 0.3,\n            \"x2_start\": 0.5,\n        },\n    },\n]\n</code></pre> <p>Next, we define the connections between the FMUs. The connections are defined as a list of dictionaries, where each dictionary contains the source and target of the connection. Here, there are three connections from <code>mass1</code> to <code>mass2</code> and one from <code>mass2</code> to <code>mass1</code>.</p> <pre><code>connections = [\n    {\n        \"source\": {\"id\": \"mass1\", \"variable\": \"x1\"},\n        \"target\": {\"id\": \"mass2\", \"variable\": \"x1\"},\n    },\n    {\n        \"source\": {\"id\": \"mass1\", \"variable\": \"v1\"},\n        \"target\": {\"id\": \"mass2\", \"variable\": \"v1\"},\n    },\n    {\n        \"source\": {\"id\": \"mass1\", \"variable\": \"a1\"},\n        \"target\": {\"id\": \"mass2\", \"variable\": \"a1\"},\n    },\n    {\n        \"source\": {\"id\": \"mass2\", \"variable\": \"F\"},\n        \"target\": {\"id\": \"mass1\", \"variable\": \"F\"},\n    },\n]\n</code></pre> <p>Finally, we create the configuration dictionary that contains the FMUs and the connections.</p> <pre><code>config = {\"fmus\": fmus, \"connections\": connections}\n</code></pre> <pre><code>from cofmupy import Coordinator\n\n# We create a Coordinator object and start it with the config dictionary\ncoordinator = Coordinator()\ncoordinator.start(config)\n\n# Let's check the default value of the mass of Mass1 in the FMU.\n# A variable in CoFmuPy is identified by a tuple (fmu_id, variable_name).\nmass_val = coordinator.get_variable((\"mass1\", \"m1\"))\nprint(\"Value of mass1 'm1' (from the FMU):\", mass_val)\n</code></pre> <p>Out:</p> <pre><code>Skipping Fixed Point Initialization\nValue of mass1 'm1' (from the FMU): [1.0]\n</code></pre> <p>We now run the simulation for 15 seconds with a 1 ms time step.</p> <pre><code>coordinator.run_simulation(step_size=0.001, end_time=15)\nresults = coordinator.get_results()\n\n# The results is a dictionary with the time and the values of the variables.\nprint(\"Results keys:\", list(results.keys()))\n</code></pre> <p>Out:</p> <pre><code>Results keys: ['time', ('mass2', 'F'), ('mass1', 'a1'), ('mass1', 'v1'), ('mass1', 'x1')]\n</code></pre> <p>We can now plot the position and velocity of the first mass over time. The results are compared with the simulation from OpenModelica, which are stored in a CSV file.</p> <pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\n\nplt.plot(results[\"time\"], results[(\"mass1\", \"x1\")], label=\"Position (CoFmuPy)\")\nplt.plot(results[\"time\"], results[(\"mass1\", \"v1\")], label=\"Velocity (CoFmuPy)\")\n\n# Load the results from OpenModelica for comparison\ndf = pd.read_csv(\"./assets/results_OpenModelica_DualMassOscillator.csv\")\nplt.plot(df[\"time\"], df[\"x1\"], \"--\", label=\"Position (OpenModelica)\")\nplt.plot(df[\"time\"], df[\"v1\"], \"--\", label=\"Velocity (OpenModelica)\")\n\nplt.title(\"Position and velocity of mass1 over time\")\nplt.xlabel(\"Time [s]\")\nplt.legend()\nplt.grid()\n</code></pre> <p></p>"},{"location":"generated/gallery/academic_examples/plot_01_dual_mass_oscillator/#conclusion","title":"Conclusion","text":"<p>In this example, we have seen how to use CoFmuPy to run the Dual Mass Oscillator system with two interconnected FMUs.</p> <p>Total running time of the script: ( 0 minutes  1.032 seconds)</p> <p> Download Python source code: plot_01_dual_mass_oscillator.py</p> <p> Download Jupyter notebook: plot_01_dual_mass_oscillator.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"user_guide/configuration_file/","title":"Writing a JSON configuration file","text":"<p>This guide will help you write a JSON configuration file to define FMUs, their properties, the connections between FMUs and connections with external data.</p>"},{"location":"user_guide/configuration_file/#structure-of-the-configuration-file","title":"Structure of the configuration file","text":"<p>The JSON configuration file consists of three main sections:</p> <ol> <li>FMUs (<code>fmus</code>): defines individual FMUs and their properties (id, path, step size,   supplier, etc.)</li> <li>Connections (<code>connections</code>): describes the connection graph.</li> <li>Global settings: specifies global configuration options.</li> </ol> <p>The skeleton of the configuration file looks like:</p> <pre><code>{\n  \"fmus\": [\n    {...},\n    {...}\n  ],\n  \"connections\": [\n    {...},\n    {...},\n    {...}\n  ],\n  \"one_global_setting\": ...,\n  \"another_global_setting\": ...\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#1-defining-fmus","title":"1. Defining FMUs","text":"<p>The <code>fmus</code> section contains the list of FMUs. Each FMU is represented by a dictionary with the following attributes:</p> <ul> <li><code>id</code>: a unique identifier for the FMU (e.g., \"FMU1\" or \"rotor\").</li> <li><code>name</code> (optional): a human-readable name for the FMU (e.g., \"load\").</li> <li><code>path</code>: the file path of the FMU (see below).</li> <li><code>stepsize</code>: the step size for the FMU simulation (e.g., \"0.3 sec\").</li> <li><code>initialization</code> (optional): key-value pairs to initialize variables in the FMU. An   initialization value could be overridden if a connection is defined for this variable.</li> <li><code>supplier</code> (optional): the supplier or creator of the FMU.</li> </ul> <p>Here is an example of an FMU description:</p> <pre><code>{\n    \"id\": \"load\",\n    \"name\": \"variable load\",\n    \"path\": \"path/to/load.fmu\",\n    \"stepsize\": \"0.2 sec\",\n    \"initialization\": {\"V_in\": 800, \"R\": 2.5},\n    \"supplier\": \"My company\"\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#paths-to-fmu-files","title":"Paths to FMU files","text":"<p>Paths to FMU files can be specified as:</p> <ol> <li>Paths relative to the JSON configuration file. CoFmuPy will search for files using    <code>path</code> value, by considering the following:<ul> <li>Files are placed at the same level than the configuration JSON file or in nested   folders.</li> <li>Each FMU file at the previously mentioned location has a unique name.</li> </ul> </li> <li>Absolute paths. In this case, the <code>path</code> field will remain untouched and the FMUs will be loaded from the specified locations.</li> </ol>"},{"location":"user_guide/configuration_file/#2-defining-connections","title":"2. Defining Connections","text":"<p>The <code>connections</code> section is a list of connections. A connection links a source to a target. The generic JSON structure for a connection is:</p> <pre><code>{\n    \"source\": {...},\n    \"target\": {...}\n}\n</code></pre> <p>Three types of connections can be defined in the JSON file:</p> <ul> <li>a connection between two FMUS</li> <li>a connection from a data source to an FMU</li> <li>a connection from an FMU to a data \"sink\" (storage or outbound data stream)</li> </ul> <p>Each connection type is described in the following subsections.</p>"},{"location":"user_guide/configuration_file/#between-two-fmus","title":"Between two FMUs","text":"<p>A connection between two FMUs represents the interaction between the subsystems in the co-simulation. The connection links the output variable of an FMU (source) to the input variable of another FMU (target). A source/target is defined with:</p> <ul> <li><code>id</code>: the FMU id as defined in the <code>fmus</code> section.</li> <li><code>variable</code>: the variable name in the FMU</li> <li><code>unit</code>: (optional) the unit of the variable</li> </ul>"},{"location":"user_guide/configuration_file/#example","title":"Example","text":"<p>For a connection from variable <code>I_out</code> of FMU <code>battery</code> to variable <code>Iload_in</code> of FMU <code>load</code>, the JSON description is:</p> <pre><code>{\n    \"source\": {\"id\": \"battery\", \"variable\": \"I1_out\", \"unit\": \"A\"},\n    \"target\": {\"id\": \"load\", \"variable\": \"Iload_in\"}\n}\n</code></pre> <p>Note</p> <p>A connection source/target has a <code>type</code> which is <code>fmu</code> by default. It is possible to add this field to be more explicit in the JSON: <code>\"type\": \"fmu\"</code>.</p>"},{"location":"user_guide/configuration_file/#from-a-data-source-to-an-fmu","title":"From a data source to an FMU","text":"<p>A connection from an external data source to an FMU is required when one input variable of a FMU is controlled by external data. The data source will be used as input values for the FMU. In CoFmuPy, we provide multiple external data sources: from single values, from a CSV file, or from a Kafka stream. You can also create your own data source (see documentation).</p> <p>The information required varies depending on the data source. For each type of source, a corresponding field <code>type</code> is defined. Note that for all types, the field <code>unit</code> is optional.</p>"},{"location":"user_guide/configuration_file/#from-single-values-literal","title":"From single values (literal)","text":"<ul> <li><code>type</code>: <code>literal</code></li> <li><code>values</code>: a key-value dictionary  with the values of the variable at   different timestamps, e.g. <code>{\"0.1\": 12.2, \"0.5\": 8.6}</code>. Note that keys in JSON must   be strings, timestamps \"0.1\" and \"0.5\" above are then represented as strings. <li><code>interpolation</code>: (optional) interpolation method (see interpolation reference). Defaults to <code>previous</code>.</li>"},{"location":"user_guide/configuration_file/#example_1","title":"Example","text":"<p>The variable <code>R</code>\u00a0of a FMU <code>resistor</code> is defined as \"literal\". The corresponding JSON description is:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"literal\",\n        \"values\": {\"0\": 100, \"12.5\": 250},\n        \"interpolation\": \"linear\"\n    },\n    \"target\": {\"id\": \"resistor\", \"variable\": \"R\", \"unit\": \"Ohm\"}\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#from-a-csv-file","title":"From a CSV file","text":"<ul> <li><code>type</code>: <code>csv</code></li> <li><code>path</code>: the path to the CSV file</li> <li><code>variable</code>: the variable name to read in the CSV. It must correspond to the column   header name.</li> <li><code>interpolation</code>: (optional) interpolation method (see interpolation reference). Defaults to <code>previous</code>.</li> </ul> <p>If you want to know how CSV files must be formatted to be correctly read by CoFmuPy, refer to the section on CSV data source.</p>"},{"location":"user_guide/configuration_file/#example_2","title":"Example","text":"<p>The variable <code>V</code> of FMU <code>battery</code> is controlled according to the values in the CSV file <code>path/to/battery_data.csv</code> (column called <code>voltage</code>). The interpolation is set to <code>previous</code>. The corresponding JSON connection is:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"csv\",\n        \"path\": \"path/to/battery_data.csv\",\n        \"variable\": \"voltage\",\n        \"unit\": \"V\",\n        \"interpolation\": \"previous\"\n    },\n    \"target\": {\"id\": \"battery\", \"variable\": \"V\", \"unit\": \"V\"}\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#from-a-kafka-stream","title":"From a Kafka stream","text":"<ul> <li><code>type</code>: <code>kafka</code></li> <li><code>uri</code>: the server URL (with port), e.g. <code>127.0.0.1:9092</code></li> <li><code>group_id</code>: the consumer group id.</li> <li><code>topic</code>: the topic to listen to.</li> <li><code>variable</code>: the variable name to read in the Kafka topic. It must correspond to the   variable name used in the Kafka message.</li> <li><code>interpolation</code>: (optional) interpolation method (see interpolation reference). Defaults to <code>previous</code>.</li> <li><code>timeout</code>: (optional) delay, in seconds, to wait (blocking) after reception of the first message before proceeding with the rest of the cosimulation. Defaults to <code>2</code>.</li> </ul> <p>If you want to know how Kafka messages must be formatted to be correctly read by CoFmuPy, refer to the section on Kafka data source.</p>"},{"location":"user_guide/configuration_file/#example_3","title":"Example","text":"<p>The variable <code>V</code> of FMU <code>battery</code> is controlled by the values from a Kafka server. A single message is formatted as follows: <code>{\"t\":, \"\":, \"\":, \"\":, }</code>. The corresponding JSON connection is:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"kafka\",\n        \"uri\": \"172.17.0.1:5000\",\n        \"group_id\": \"my_group\",\n        \"topic\": \"cofmupy_topic\",\n        \"variable\": \"voltage\",\n        \"interpolation\": \"linear\",\n        \"timeout\": 1,\n\n    },\n    \"target\": {\"id\": \"battery\", \"variable\": \"V\", \"unit\": \"V\"}\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#from-an-fmu-to-a-data-sink","title":"From an FMU to a data sink","text":"<p>A connection from an FMU to a data \"sink\" represents a connection towards the \"outside\". A sink can be a data storage system (e.g. a file or database system) or an outbound data stream (e.g. a Kafka data stream). The JSON description is equivalent to the previous cases.</p> <p>By default, CoFmuPy will save all output variables of the co-simulation in a single CSV file for each simulation step. The location of this file is <code>storage/results.csv</code>.</p>"},{"location":"user_guide/configuration_file/#to-a-csv-file","title":"To a CSV file","text":"<ul> <li><code>type</code>: <code>csv</code></li> <li><code>output_dir</code>: the directory where the CSV file will be created.</li> <li><code>variable</code>: the name of the variable, used as the header column name in the CSV file.</li> <li><code>overwrite</code>: (optional) overwrite an existing file if <code>true</code>. Defaults to <code>true</code>.</li> <li><code>unit</code>: (optional) the unit of the variable.</li> </ul>"},{"location":"user_guide/configuration_file/#example_4","title":"Example","text":"<pre><code>{\n    \"source\": {\"id\": \"FMU1\", \"variable\": \"V_out\", \"unit\": \"V\"},\n    \"target\": {\n        \"type\": \"csv\",\n        \"id\": \"csv_out_V\",\n        \"output_dir\": \"path/to/folder/\",\n        \"variable\": \"FMU1.V\",\n        \"overwrite\": true\n    }\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#to-a-kafka-stream","title":"To a Kafka stream","text":"<ul> <li><code>id</code>: an ID to name the connection</li> <li><code>uri</code>: the Kafka server URL (with the port number)</li> <li><code>variable</code>: the name of the variable, used to send messages on the Kafka topic.</li> <li><code>group_id</code>: the consumer group id.</li> <li><code>topic</code>: the topic to listen to.</li> <li><code>unit</code>: (optional) the unit of the variable.</li> </ul>"},{"location":"user_guide/configuration_file/#example_5","title":"Example","text":"<p>A JSON example for Kafka data stream:</p> <pre><code>{\n    \"source\": {\"id\": \"FMU2\", \"variable\": \"I_out\", \"unit\": \"A\"},\n    \"target\": {\n        \"type\": \"kafka\",\n        \"id\": \"kafka_out_1\",\n        \"uri\": \"172.17.0.1:5050\",\n        \"variable\": \"FMU2.I\",\n        \"config\": {\"group_id\": \"my_group\", \"topic\": \"FMU2.I\"},\n        \"unit\": \"A\"\n    }\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#3-global-settings","title":"3. Global settings","text":"<p>Besides the description of the FMUs and the connections, the JSON configuration file also specifies global settings used by CoFmuPy.</p> <ul> <li><code>cosim_method</code>: specifies the algorithm for solving system loops (e.g., <code>jacobi</code>,   <code>gauss-seidel</code>).</li> <li><code>iterative</code>: boolean to specify whether the master algorithm solves algebraic loops in   an iterative way (<code>true</code>) or in a single pass (<code>false</code>).</li> <li><code>edge_sep</code>: defines the separator for connection naming. Default is <code>-&gt;</code>.</li> <li><code>root</code>: specifies the root directory for relative paths.</li> </ul>"},{"location":"user_guide/configuration_file/#tips-for-writing-a-configuration-file","title":"Tips for writing a configuration file","text":"<ul> <li>Use unique IDs: ensure all FMUs and data sources have unique IDs.</li> <li>Verify paths: check that all path attributes are valid and accessible.</li> <li>Specify units: use consistent units across all variables to avoid mismatches.</li> <li>Test connections: verify connections are logical and complete.</li> <li>Validate JSON: Use a JSON validator to ensure the configuration file is error-free.</li> </ul> <p>This guide should help users create and manage their JSON configuration files effectively. A full JSON example is provided in the \"Examples\" section.</p>"},{"location":"user_guide/configuration_file/#interpolation-reference","title":"Interpolation reference","text":"<p>Interpolation is used when the system needs a value between two time points when data external to FMUs is used (literal, csv, kafka, etc.).</p> <p>The interpolation uses <code>cofmupy.utils.Interpolator</code> class which supports a wide variety of interpolation methods. The currently tested methods are:</p> <ul> <li><code>previous</code>, which returns the value at the previous time point (default value)</li> <li><code>linear</code>, which calculates a linearly interpolated value between the previous and   next points.</li> </ul> <p>The other methods will log the following warning:</p> <p><code>Method '{method}' is in beta version. We recommend using 'linear' or 'previous'</code></p> <p>For more details, please refer to the corresponding notebook</p>"},{"location":"user_guide/cosimulation_initialization/","title":"Fixed-Point Initialization in CoFmuPy","text":""},{"location":"user_guide/cosimulation_initialization/#understanding-fixed-point-initialization","title":"Understanding Fixed-Point Initialization","text":"<p>In a co-simulation involving multiple FMUs, the user-defined initial state \\(x_0\\) represents the starting values for all system variables. However, if \\(x_0\\) is not dynamically consistent, meaning it does not satisfy the physical constraints of the system, the simulation may start from an unrealistic state, leading to numerical instabilities or incorrect results.</p> <p>To correct this, CoFmuPy provides a fixed-point initialization process that finds a valid initial state \\(x_0^*\\) close to \\(x_0\\), such that:</p> \\[ f(x_0^*) = x_0^* \\] <p>where \\(f\\) is the numerical time integrator, responsible for advancing the system\u2019s state to the next time step (basically built on <code>do_step</code>). This ensures that \\(x_0^*\\) is a fixed-point solution, meaning the system starts in a physically valid configuration.</p>"},{"location":"user_guide/cosimulation_initialization/#enabling-fixed-point-initialization-in-cofmupy","title":"Enabling Fixed-Point Initialization in CoFmuPy","text":"<p>To ensure a dynamically valid initialization, you can enable the fixed-point initialization by setting <code>fixed_point_init=True</code> when starting the simulation coordinator:</p> <pre><code>coordinator.start(config_path, fixed_point_init=True)\n</code></pre> <p>When <code>fixed_point_init=False</code>, CoFmuPy will use the user-provided or default initial values without verifying their validity. This may be faster, but it can lead to inconsistencies in coupled FMUs, which may cause instability or incorrect results.</p> <p>When <code>fixed_point_init=True</code>, CoFmuPy internally:</p> <ol> <li>Constructs an optimization function that represents the co-simulation architecture.</li> <li>Solves for a valid initial state \\(x_0^\u2217\\) using a numerical solver, ensuring consistency across all FMUs.</li> <li>Uses <code>fsolve</code> from SciPy by default to find a solution, using:<ul> <li>The minimum of default integration time steps defined in each FMU\u2019s XML metadata.</li> <li>Default solver parameters.</li> </ul> </li> </ol>"},{"location":"user_guide/cosimulation_initialization/#customizing-the-fixed-point-solver","title":"Customizing the Fixed-Point Solver","text":"<p>By default, CoFmuPy uses SciPy's <code>fsolve</code> with its default arguments. However, you can customize:</p> <ul> <li>The solver method (<code>fsolve</code> or other supported solvers).</li> <li>The fixed-point iteration step size (<code>time_step</code>).</li> <li>The solver\u2019s argument passed as keyword arguments dictionnary</li> </ul> <p>To modify these settings, pass the desired options using <code>fixed_point_kwargs</code>:</p> <pre><code> # Customize fixed point solver\n fixed_point_kwargs = {\n      \"solver\": \"fsolve\",\n      \"time_step\": 5e-8,\n      \"tolerance\": 1e-5,\n      \"max_iterations\": 100,\n  }\n\n  coordinator.start(config_path, fixed_point_init=True, fixed_point_kwargs=fixed_point_kwargs)\n</code></pre>"},{"location":"user_guide/cosimulation_initialization/#supported-solvers","title":"Supported Solvers","text":"<p>Currently, CoFmuPy supports the following solver:</p> <ul> <li><code>scipy.optimize.fsolve</code><ul> <li>Used for finding roots of nonlinear equations via a hybrid Powell method.</li> <li>Automatically approximates the Jacobian if not provided.</li> <li>For more details, refer to the SciPy documentation:\ud83d\udc49 fsolve \u2014 SciPy v1.15.1 Manual</li> </ul> </li> </ul> <p>Support for additional solvers is planned in future versions.</p>"},{"location":"user_guide/data_sources/","title":"Managing data sources","text":"<p>External data can be useful to control variable parameters, to use as input from an other system simulation or just to get from measurements from a physical twin. CoFmuPy provides multiple data source handlers detailed below.</p> <p>Whatever the data source, the connection between the data source and the target variable of the simulation is defined in the JSON configuration file as a connection:</p> <ul> <li>a <code>source</code> field defining the data handler configuration (see below the supported data   handlers).</li> <li>a <code>target</code> field corresponding to the FMU variable connected to the source.</li> </ul> <pre><code>\"connections\":\u00a0[\n    {\n        \"source\": {...},\n        \"target\": {\"id\": \"fmu_target\", \"variable\": \"my_variable\", \"unit\": \"my_unit\"}\n    },\n    {\n        ...\n    }\n]\n</code></pre>"},{"location":"user_guide/data_sources/#single-values-the-simplest-approach-literal-data-handler","title":"Single values, the simplest approach (<code>literal</code> data handler)","text":"<p>If your variable is fixed or only changes a few times, this is the simplest way to define the values. This is done directly in the JSON configuration file. The expected format is a dictionary with times and values. For example <code>{\"0\": 1.0, \"0.5\": 2.8}</code> corresponds to a variable that takes value 1.0 at the beginning of the simulation (t=0) and have a single change at t=0.5 with the value 2.8. You can have either zero changes (i.e. a fixed value for the whole simulation) or any changes you want. As JSON only accepts string keys, remember that time instants must be with quote (e.g. <code>\"0.5\"</code>).</p> <p>The JSON configuration file must follow the syntax below:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"literal\",\n        \"values\": {\"0\": 0, \"0.1\": 12.2, \"0.5\": 8.6},\n        \"unit\": \"A\"\n    },\n    \"target\": {\"id\": \"FMU2\", \"variable\": \"I_load\", \"unit\": \"A\"}\n}\n</code></pre> <p>In case the variable has many changes, we suggest to use the second method, a CSV file.</p>"},{"location":"user_guide/data_sources/#a-csv-file","title":"A CSV file","text":"<p>Data can be read directly from a CSV file.  The file must start with a header containing the names of the columns: a column titled <code>t</code> containing the time instants, and the other columns titled with variable names. For example, the CSV header could be <code>t,R,V_out,Iload</code>.</p> <p>Here is an example of data source CSV file:</p> <pre><code>t,R,V_out,Iload\n0,100,5,0\n0.1,100,5,0.8\n0.5,100,10,0.8\n0.7,200,5,2.5\n</code></pre> <p>To connect CSV data to an FMU variable in CoFmuPy, the connection is described in the JSON configuration file as follows:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"csv\",\n        \"path\": \"path/to/the/file.csv\",\n        \"variable\": \"R\",\n        \"unit\": \"Ohm\"\n    },\n    \"target\": {\"id\": \"resistor\", \"variable\": \"R\", \"unit\": \"Ohm\"}\n}\n</code></pre>"},{"location":"user_guide/data_sources/#a-kafka-stream","title":"A Kafka stream","text":"<p>The last data source proposed in CoFmuPy is a Kafka broker. Data is retrieved from a Kafka topic in a specific format: a message must contain the time instants and their corresponding values as a dictionary:</p> <pre><code>{\"t\": 0, \"R\": 100},\n{\"t\": 0.1, \"R\": 200}\n</code></pre> <p>To connect the Kafka topic to a FMU variable, the connection is described in the JSON configuration file as follows:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"kafka\",\n        \"uri\": \"localhost:5000\",\n        \"group_id\": \"my_group\",\n        \"topic\": \"V_in\",\n        \"variable\": \"V_in\",\n        \"unit\": \"V\"\n    },\n    \"target\": {\"id\": \"voltage_source\", \"variable\": \"V_in\", \"unit\": \"V\"}\n}\n</code></pre> <p>Some parameters of the Kafka stream must be set:</p> <ul> <li><code>uri</code>: the address of the Kafka server (with port information)</li> <li><code>group_id</code>: the consumer group id</li> <li><code>topic</code>: the topic to listen to</li> </ul> <p>For a more detailed example of Kafka configuration, please read Kafka Handler Configuration. For a deeper understanding of the Kafka Thread Manager, see this page.</p>"},{"location":"user_guide/data_sources/#interpolation-between-time-instants-optional-parameter","title":"Interpolation between time instants (optional parameter)","text":"<p>Whatever the data source, an optional parameter <code>interpolation</code> can be added to the configuration. This parameter specifies the type of interpolation used when the system needs a value between two time points. It can be set to <code>previous</code>, which returns the previous value (default value), or <code>linear</code>, which calculates a linearly interpolated value between the previous and next points. For example for a value of 100 at t=0.5 and 200 at t=0.7, if we want to retrieve the value at t=0.65:</p> <ul> <li>if <code>interpolation=\"previous\"</code> the data handler will return 100, being the previous   value at t=0.5.</li> <li>if <code>interpolation=\"linear\"</code> the data handler will return 175, being the linear   interpolation between t=0.5 (R=100) and t=0.7 (R=200).</li> </ul>"},{"location":"user_guide/data_sources/#custom-data-sources","title":"Custom data sources","text":"<p>For advanced users, it is possible to create your own custom data stream handler that feeds FMUs with external data. See page Data Stream Handler Module.</p>"},{"location":"user_guide/helpers/","title":"\ud83d\udee0\ufe0f CoFmuPy Helper Scripts","text":"<p>CoFmuPy provides a set of helper scripts designed to simplify working with Functional Mock-up Units (FMUs) and co-simulation workflows. These scripts offer debugging tools, model extraction utilities, and automation features to enhance user experience.</p>"},{"location":"user_guide/helpers/#available-helper-scripts","title":"\ud83d\udcdc Available Helper Scripts","text":"Script Name Description <code>cofmupy-extract-fmu</code> Extracts and displays all metadata from an FMU file. <code>User Interface</code> \ud83d\udea7 Coming soon..."},{"location":"user_guide/helpers/#extracting-fmu-information-with-cofmupy-extract-fmu","title":"\ud83d\udce6 Extracting FMU Information with <code>cofmupy-extract-fmu</code>","text":"<p>The <code>cofmupy-extract-fmu</code> helper script is a command-line tool designed to extract and display all relevant information from an FMU (Functional Mock-up Unit) file. It helps users quickly inspect FMU metadata, including:</p> <ul> <li>Inputs, outputs, and parameters</li> <li>Default values and variable types</li> <li>Integration step size</li> </ul> <p>This tool is particularly useful for debugging, documentation, and ensuring FMU compatibility before running co-simulations.</p>"},{"location":"user_guide/helpers/#usage","title":"\ud83d\udcdc Usage","text":"<p>The <code>cofmupy-extract-fmu</code>\u00a0script is executed from the command line with the following syntax:</p> <pre><code>cofmupy-extract-fmu &lt;path_to_fmu_file&gt;\n</code></pre> <p>For example, if you have an FMU file named <code>model.fmu</code> in the current directory, run:</p> <pre><code>cofmupy-extract-fmu model.fmu\n</code></pre> <p>This will extract and display all the FMU metadata in a well-structured table.</p>"},{"location":"user_guide/advanced/kafka_configuration/","title":"KafkaHandlerConfig","text":"<p><code>KafkaHandlerConfig</code> is a dataclass used to configure Kafka connections for data handlers. It provides default values and validates configuration parameters automatically.</p>"},{"location":"user_guide/advanced/kafka_configuration/#1-initialization","title":"1. Initialization","text":"<p>You can create an instance by passing the required parameters:</p> <pre><code>from cofmupy import KafkaHandlerConfig\n\nconfig_dict = {\n    \"uri\": \"localhost:9092\",\n    \"topic\": \"my_topic\",\n    \"group_id\": \"my_group\",\n    \"timeout\": 0.5,\n    \"interpolation\": \"linear\",\n    \"auto_offset_reset\": \"latest\",\n    \"enable_auto_commit\": False\n}\n\nconfig = KafkaHandlerConfig(**config_dict)\n</code></pre>"},{"location":"user_guide/advanced/kafka_configuration/#required-parameters","title":"Required Parameters","text":"<ul> <li><code>topic</code> (str): Kafka topic to subscribe to.</li> <li><code>uri</code> (str): url and port to listen. Must be in the form <code>\"server_url:port\"</code>.</li> <li><code>group_id</code> (str): Kafka consumer group.  Note: Missing keys will raise a <code>KeyError</code>.</li> </ul>"},{"location":"user_guide/advanced/kafka_configuration/#optional-parameters","title":"Optional Parameters","text":"<ul> <li><code>timeout</code> (float, default <code>0.1</code>): Maximum wait time for Kafka operations (seconds). Must be non-negative.</li> <li><code>interpolation</code> (str, default <code>\"previous\"</code>): Method to interpolate missing data. Must be one of the registered methods in <code>Interpolator</code>.</li> <li><code>auto_offset_reset</code> (str, default <code>\"earliest\"</code>): Kafka consumer offset reset strategy. Options: <code>\"earliest\"</code>, <code>\"latest\"</code>, <code>\"none\"</code>.</li> <li><code>enable_auto_commit</code> (bool, default <code>True</code>): Whether Kafka consumer auto-commits offsets. Note: Optional keys override the default values.</li> </ul>"},{"location":"user_guide/advanced/kafka_configuration/#validation","title":"Validation","text":"<ul> <li><code>port</code> must be numeric.</li> <li><code>timeout</code> must be non-negative.</li> <li><code>auto_offset_reset</code> must be a valid value (<code>earliest</code>, <code>latest</code>, <code>none</code>).</li> <li><code>interpolation</code> must be a valid method registered in <code>Interpolator</code>.</li> </ul>"},{"location":"user_guide/advanced/kafka_configuration/#2-usage","title":"2. Usage","text":"<p>Once created, <code>KafkaHandlerConfig</code> instances store all necessary Kafka connection parameters:</p> <pre><code>print(config.topic)           # \"my_topic\"\nprint(config.server_url)      # \"localhost\"\nprint(config.port)            # \"9092\"\nprint(config.interpolation)   # \"linear\"\n</code></pre> <ul> <li>This object is typically passed to <code>KafkaDataStreamHandler</code> classes that manage consumption or production of data streams.</li> </ul>"},{"location":"user_guide/advanced/kafka_configuration/#3-logging-and-error-handling","title":"3. Logging and Error Handling","text":"<ul> <li>Missing required dictionary keys are logged with <code>logger.error</code>.</li> <li>Invalid values for <code>port</code>, <code>timeout</code>, <code>auto_offset_reset</code>, or <code>interpolation</code> raise <code>ValueError</code> during initialization.</li> </ul>"},{"location":"user_guide/advanced/kafka_thread_manager/","title":"KafkaThreadManager","text":"<p><code>KafkaThreadManager</code> is a utility class to manage a background thread that consumes messages from a Kafka topic using a given Kafka consumer and a user-defined callback.</p>"},{"location":"user_guide/advanced/kafka_thread_manager/#1-initialization","title":"1. Initialization","text":"<pre><code>from cofmupy.data_stream_handler.kafka_utils import KafkaThreadManager\n\nmanager = KafkaThreadManager(\n    consumer=my_kafka_consumer,\n    callback=my_callback_function,\n    thread_lifetime=40  # optional, default 40 seconds\n)\n</code></pre>"},{"location":"user_guide/advanced/kafka_thread_manager/#parameters","title":"Parameters","text":"<ul> <li> <p><code>consumer</code> (Kafka consumer object)</p> </li> <li> <p>Typically a <code>confluent_kafka.Consumer</code>.</p> </li> <li> <p>Handles connection and message polling from Kafka.</p> </li> <li> <p><code>callback</code> (function)</p> </li> <li> <p>Function to process each consumed message.</p> </li> <li>Signature: <code>callback(msg)</code> where <code>msg</code> is a Kafka message object.</li> <li> <p>Error handling should be implemented in the callback.</p> </li> <li> <p><code>thread_lifetime</code> (float, optional, default <code>40</code>)</p> </li> <li> <p>Maximum time (in seconds) the consuming thread should run.</p> </li> <li>If <code>None</code> or <code>0</code>, the thread runs indefinitely until <code>stop()</code> is called.</li> </ul>"},{"location":"user_guide/advanced/kafka_thread_manager/#2-start-the-consumer-thread","title":"2. Start the consumer thread","text":"<pre><code>manager.start()\n</code></pre> <ul> <li>Spawns a daemon thread to run <code>_consume_loop</code>.</li> <li>Polls messages from Kafka and calls <code>callback(msg)</code> for each message.</li> <li>Logs when the thread starts:</li> </ul> <pre><code>Kafka consumer started consuming in thread '&lt;thread_name&gt;'\n</code></pre>"},{"location":"user_guide/advanced/kafka_thread_manager/#3-consuming-loop-_consume_loop","title":"3. Consuming loop (<code>_consume_loop</code>)","text":"<ul> <li>Runs internally in a separate thread.</li> <li> <p>Logic:</p> <ol> <li>Track elapsed time (if <code>thread_lifetime</code> is set).</li> <li>Poll Kafka messages with <code>consumer.poll(timeout=1)</code>. Note: <code>poll</code> is a <code>confluent_kafka.Consumer</code> method.</li> <li>If a message is received, call <code>callback(msg)</code>.</li> <li> <p>Stops when:</p> <ul> <li>Thread lifetime is exceeded, or</li> <li><code>stop()</code> is called manually.</li> </ul> </li> </ol> </li> <li> <p>Logs errors during polling and a message when the thread stops.</p> </li> </ul>"},{"location":"user_guide/advanced/kafka_thread_manager/#4-stop-the-thread-gracefully","title":"4. Stop the thread gracefully","text":"<pre><code>manager.stop()\n</code></pre> <ul> <li>Sets <code>running = False</code>.</li> <li>Waits for the thread to finish (<code>thread.join()</code>).</li> <li>Closes the Kafka consumer.</li> <li>Logs: <code>\"Kafka consumer thread stopped.\"</code></li> </ul>"},{"location":"user_guide/advanced/kafka_thread_manager/#notes","title":"\u26a0\ufe0f Notes","text":"<ul> <li>The callback function must handle its own exceptions; otherwise, they propagate to the consuming thread.</li> <li>Thread is a daemon, so it won\u2019t block Python shutdown if the main program exits.</li> <li>Use <code>thread_lifetime</code> to limit how long the consumer runs automatically; otherwise, call <code>stop()</code> manually.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/","title":"Data Stream Handler module","text":"<p>This section describes the architecture, usage, and available implementations of data stream handlers within CoFmuPy.</p>"},{"location":"user_guide/advanced/stream_handler_module/#1-overview","title":"1. Overview","text":"<p>The <code>data_stream_handler</code> module provides a unified interface for ingesting and interacting with live or recorded data streams, which serve as inputs to Digital Twin prototypes. It enables users to seamlessly switch between data sources (e.g., CSV files, Kafka topics, or local in-memory streams) through a consistent API. This abstraction layer allows developers to prototype and test Digital Twins without rewriting data ingestion logic.</p>"},{"location":"user_guide/advanced/stream_handler_module/#core-concepts","title":"Core Concepts","text":"<ul> <li>Modularity &amp; Extensibility: All stream handlers inherit from <code>BaseDataStreamHandler</code>, which defines the standard interface and registration mechanism for new handlers.</li> <li>Handler Factory: Stream handler instances are dynamically instantiated using the <code>BaseDataStreamHandler.create_handler()</code> factory method, based on the configuration dictionary.</li> <li>Grouped data streams: Control over dynamic instantiation and variable assignment is provided by <code>BaseDataStreamHandler.is_equivalent_stream()</code> and <code>BaseDataStreamHandler.add_variable()</code> methods, respectively.</li> <li>Alias Mapping: A mechanism for mapping CoFmuPy internal connections (as <code>(fmu, variable)</code> tuples) to external variables in the input data stream.</li> <li>Data Interpolation: Each handler supports time-based interpolation (e.g., step-wise or linear), using the shared <code>Interpolator</code> utility.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#included-handlers","title":"Included Handlers","text":"<ul> <li>CSVDataStreamHandler (<code>csv</code>): Reads data from a static CSV file.</li> <li>KafkaDataStreamHandler (<code>kafka</code>): Connects to a Kafka topic, consumes real-time messages in a separate thread and manages buffering.</li> <li>LocalDataStreamHandler: Provides a lightweight in-memory option for development, unit testing, or variable with very few variations in time.</li> </ul> <p>Each handler needs to include (explained below):</p> <ul> <li><code>get_data(t)</code></li> <li><code>is_equivalent_stream(config)</code></li> <li><code>add_variable(variable, alias)</code></li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#example-use","title":"Example Use","text":"<pre><code>config = {\n    \"type\": \"csv\",\n    \"config\": {\n        \"path\": \"data/simulation.csv\",\n        \"interpolation\": \"linear\"\n    }\n}\n\nhandler = BaseDataStreamHandler.create_handler(config)\nhandler.add_variable((\"robot\", \"position\"), \"robot_pos\")\ndata_at_t = handler.get_data(t=5.0)\n</code></pre> <p>This architecture enables rapid experimentation and stream interchangeability, making it ideal for fast prototyping of Digital Twin models.</p>"},{"location":"user_guide/advanced/stream_handler_module/#2-basedatastreamhandler","title":"2. BaseDataStreamHandler","text":"<p>The <code>BaseDataStreamHandler</code> provides the abstract common interface for all data stream handlers, in particular, it:  * Defines a uniform API for time-based data retrieval (<code>get_data</code>) * Enables extensibility through a registry and factory method * Manages alias mappings between CoFmuPy connections and stream variables * Supports equivalence checks for grouping data streams in a single handler (<code>is_equivalent_stream</code>)</p>"},{"location":"user_guide/advanced/stream_handler_module/#core-methods","title":"Core Methods","text":"<ul> <li> <p><code>get_data(t: float) -&gt; pd.Series</code>   Must be implemented by child classes to return the data at time <code>t</code>. Interpolation behavior is defined per handler instance.</p> </li> <li> <p><code>add_variable(variable: tuple, stream_alias: str)</code>   Updates the mapping between a CoFmuPy connection variable (as a <code>(fmu, variable)</code> tuple) and its name in the data stream.</p> </li> <li> <p><code>is_equivalent_stream(config: dict) -&gt; bool</code>   Used to check if a new config would produce an equivalent stream handler instance (e.g., same CSV file path, same Kafka topic, etc.).</p> </li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#handler-registration-and-factory","title":"Handler Registration and Factory","text":"<p>All subclasses must define a unique <code>type_name</code> class attribute. They are automatically registered via <code>register_handler</code> and can be instantiated using:</p> <pre><code>handler = BaseDataStreamHandler.create_handler(config_dict)\n</code></pre> <p>The <code>config_dict</code> must follow this structure:</p> <pre><code>{\n    \"type\": \"&lt;type_name&gt;\",\n    \"config\": { ... }  # handler-specific config\n}\n</code></pre> <p>For integration with the rest of CoFmuPy modules, new subclasses have to be imported and registered in the module's <code>__init__.py</code>.</p>"},{"location":"user_guide/advanced/stream_handler_module/#alias-mapping","title":"Alias Mapping","text":"<p>Handlers store connection mappings internally using a dictionary:</p> <pre><code>alias_mapping: dict[tuple[str, str], str]\n</code></pre> <p>This mapping is used to translate CoFmuPy internal references to stream-specific variable names during data retrieval.</p>"},{"location":"user_guide/advanced/stream_handler_module/#3-available-handlers","title":"3. Available Handlers","text":"<p>The following data stream handlers are included by default and can be selected using the <code>type</code> field in the configuration. Each handler implements the core interface defined in <code>BaseDataStreamHandler</code>, with behavior tailored to its data source.</p>"},{"location":"user_guide/advanced/stream_handler_module/#31-csvdatastreamhandler-type-csv","title":"3.1. CSVDataStreamHandler (<code>type: \"csv\"</code>)","text":"<p>Reads time-indexed data from a static CSV file.</p>"},{"location":"user_guide/advanced/stream_handler_module/#configuration","title":"Configuration","text":"<pre><code>{\n    \"type\": \"csv\",\n    \"config\": {\n        \"path\": \"path/to/file.csv\",\n        \"interpolation\": \"previous\"  # optional, defaults to \"previous\"\n    }\n}\n</code></pre>"},{"location":"user_guide/advanced/stream_handler_module/#notes","title":"Notes","text":"<ul> <li>The entire CSV is loaded into memory at initialization.</li> <li>Time interpolation is handled using the configured method (e.g., \"previous\", \"linear\").</li> <li>Use <code>add_variable()</code> to map model variables to column names in the file.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#32-localdatastreamhandler","title":"3.2. LocalDataStreamHandler","text":"<p>Lightweight handler designed for manually provided in-memory data.</p>"},{"location":"user_guide/advanced/stream_handler_module/#use-cases","title":"Use Cases","text":"<ul> <li>Scenario implementation</li> <li>Fast iteration with known values</li> <li>Manual injection of sequence of parameters</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#notes_1","title":"Notes","text":"<ul> <li>Values can be passed dynamically in the workflow.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#33-kafkadatastreamhandler-type-kafka","title":"3.3. KafkaDataStreamHandler (<code>type: \"kafka\"</code>)","text":"<p>The <code>KafkaDataStreamHandler</code> connects to a Kafka topic to receive online data. It uses background threading and fast buffering to ensure consistent access to interpolated time-series values, even under asynchronous message arrival.</p> <p>This handler is suited for live Digital Twin deployments or fast-loop simulation environments requiring high-frequency streaming input.</p>"},{"location":"user_guide/advanced/stream_handler_module/#configuration_1","title":"Configuration","text":"<p><pre><code>{\n    \"type\": \"kafka\",\n    \"config\": {\n        \"topic\": \"digital-twin\",\n        \"bootstrap_servers\": \"localhost:9092\",\n        \"group_id\": \"my-consumer-group\",\n        \"interpolation\": \"linear\",\n        \"timeout\": 2, # timeout for consuming messages\n        \"kafka_backend_conf\":\"path_to/backend_config.json\"\n    }\n}\n</code></pre> The configuration dictionary is parsed into a <code>KafkaHandlerConfig</code> dataclass (where data types are enforced) via <code>KafkaHandlerConfig.from_dict()</code>. The <code>\"kafka_backend_conf\"</code> argument allows to kafka network-specific configuration as a separate JSON. Example <code>backend_config.json</code> with the available arguments:</p> <pre><code>{\n    \"first_msg_timeout\": 35,\n    \"first_delay\": 4,\n    \"max_retries\": 3,\n    \"retry_delay\": 0.02,\n    \"offset_reset\": \"earliest\",\n    \"max_buffer_len\": 10,\n    \"thread_lifetime\": 1000000,\n}\n</code></pre>"},{"location":"user_guide/advanced/stream_handler_module/#internal-architecture","title":"Internal Architecture","text":"<p>To manage Kafka consumption robustly and efficiently, the handler relies on utility components from <code>kafka_utils.py</code>:</p>"},{"location":"user_guide/advanced/stream_handler_module/#kafkahandlerconfig","title":"<code>KafkaHandlerConfig</code>","text":"<ul> <li>A dataclass that encapsulates all Kafka-related configuration fields (e.g., topic, group ID, server URL).</li> <li>Used to validate and control default values for incoming configuration data.</li> <li>It also reads and parses optional network-related configuration from a separate JSON.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#kafkathreadmanager","title":"<code>KafkaThreadManager</code>","text":"<ul> <li>Manages a background thread that continuously consumes Kafka messages.</li> <li>To ensure modularity it calls a user-defined callback (e.g. <code>KafkaDataStreamHandler._handle_message</code>) for each message received. </li> <li>Supports thread lifecycle control via <code>start()</code> and <code>stop()</code> methods.</li> <li>Avoids blocking the main simulation loop.</li> <li>Works in an independent and separated thread. </li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#parse_kafka_messagemsg","title":"<code>parse_kafka_message(msg)</code>","text":"<ul> <li>Parses raw Kafka messages into a CoFmuPy compatible Python <code>dict</code> with a <code>t</code> field (timestamp) and associated values under alias keys.</li> <li>If a different incoming data structure is used, this function provides an interface to the rest of the API.</li> <li>Falls back to raw string output on failure, allowing standalone use of the data handler.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#lifecycle","title":"Lifecycle","text":"<ol> <li> <p>Initialization:</p> </li> <li> <p>The consumer is instantiated with topic subscription (lazy) using <code>_create_consumer()</code>.</p> </li> <li> <p>The thread manager is started via <code>start_consumer()</code>, triggering background consumption.</p> </li> <li> <p>Message Handling:</p> </li> <li> <p>For the first message, the consumption loop retries until <code>first_msg_timeout</code> is reached, pausing for <code>first_delay</code> between attempts.</p> </li> <li>After the first message is received (to allow for Kafka broker consumer group stabilization, etc.), the loop continues retrying for up to <code>max_retries</code> sessions. Each session consists of sequential attempts until <code>timeout</code> is reached, with a <code>retry_delay</code> pause between each attempt.</li> <li>As new messages arrive, they are parsed and added to self.data in a thread safe way.</li> <li> <p>The data is fetched in <code>_build_out_dict</code> method using timestamp (<code>t</code>) and the interpolation method.</p> </li> <li> <p>Data Access:</p> </li> <li> <p><code>get_data(t)</code> returns the interpolated values at a specific timestamp.</p> </li> <li> <p>Interpolation uses the same <code>utils.Interpolator</code> class as other handlers.</p> </li> <li> <p>Shutdown:</p> </li> <li> <p>Call <code>stop_consumer()</code> when the handler is no longer needed to gracefully stop the background thread and release Kafka resources.</p> </li> </ol>"},{"location":"user_guide/advanced/stream_handler_module/#notes_2","title":"Notes","text":"<ul> <li>Kafka topics must publish messages containing a <code>t</code> timestamp field when used the default code.</li> <li>Otherwise, you can override <code>_handle_message</code> and/or <code>parse_kafka_message</code> if a custom workflow is required (decoding, data structure, etc.).</li> <li>Lazy subscription ensures the consumer is only connected when needed.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#4-interpolation","title":"4. Interpolation","text":"<p>All data stream handlers support time-based interpolation when returning values via <code>get_data(t)</code>. The interpolation logic is delegated to a shared utility class: <code>Interpolator</code>, located in the <code>utils</code> module.</p>"},{"location":"user_guide/advanced/stream_handler_module/#supported-methods","title":"Supported Methods","text":"<ul> <li><code>\"previous\"</code> (default): Returns the most recent known value at or before time <code>t</code>.</li> <li><code>\"linear\"</code>: Performs linear interpolation between the two closest known timestamps.</li> <li>Additional methods are supported by the <code>Interpolator</code> class but will raise a warning since not tested in integration.</li> <li>Custom methods may be implemented using the <code>Interpolator</code> class.</li> </ul>"},{"location":"user_guide/advanced/stream_handler_module/#usage","title":"Usage","text":"<p>Interpolation is configured per handler using the <code>interpolation</code> field in the config:</p> <pre><code>\"interpolation\": \"linear\"\n</code></pre> <p>This setting is passed to the <code>Interpolator</code> instance during handler initialization. Each handler is responsible for how and when to invoke the interpolator, typically inside the <code>get_data(t)</code> method.</p>"},{"location":"user_guide/advanced/stream_handler_module/#5-extending-with-custom-handlers","title":"5. Extending with Custom Handlers","text":"<p>You can add support for new data sources by implementing a custom subclass of <code>BaseDataStreamHandler</code>:</p> <ol> <li> <p>Subclass <code>BaseDataStreamHandler</code>    Implement the abstract methods:</p> </li> <li> <p><code>__init__(self, config)</code></p> </li> <li><code>get_data(self, t: float)</code></li> <li> <p><code>is_equivalent_stream(self, config: dict)</code></p> </li> <li> <p>Set a unique <code>type_name</code>    This will be used in the configuration to identify your handler.</p> </li> <li> <p>Register the handler    At module load time (e.g., in your custom handler file):</p> </li> </ol> <pre><code>BaseDataStreamHandler.register_handler(MyCustomHandler)\n</code></pre> <ol> <li>Use via configuration    Once registered, the handler can be created using the factory method:</li> </ol> <pre><code>handler = BaseDataStreamHandler.create_handler(config_dict)\n</code></pre>"},{"location":"user_guide/advanced/stream_handler_module/#tips","title":"Tips","text":"<ul> <li>Use <code>add_variable()</code> to support alias mapping if integrattion with other CoFmuPy modules is required.</li> <li>Follow the same interpolation pattern as built-in handlers for consistency.</li> <li>Use <code>is_equivalent_stream()</code> to help avoid redundant handler instances.</li> </ul>"}]}