{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#about-cofmpy","title":"\ud83d\udc4b About CoFMPy","text":"<p>CoFMPy is a Python library designed for co-simulating Functional Mock-up Units (FMUs). It offers advanced master coordination features, such as solving algebraic loops between FMUs and managing the interaction between various simulation components. This library provides a seamless interface to orchestrate complex physics simulations and handle the data exchange between FMUs.</p> <p>CoFMPy can be used in two different ways: either from a web interface or directly in a Python script. The documentation is available online.</p>"},{"location":"#installation","title":"\ud83d\udc3e Installation","text":"<p>CoFMPy is available on PyPI and can be installed using <code>pip</code>:</p> <pre><code>pip install cofmpy\n</code></pre>"},{"location":"#graphical-interface","title":"\ud83d\udda5\ufe0f Graphical Interface","text":"<p>The web interface allows users to interact with the cosimulation through a user-friendly graphical interface.</p> <p>You can start the web application by running the following command:</p> <pre><code>streamlit run cofmpy/webapp/main.py\n</code></pre> <p>Once the web application is running, you can access it by opening your web browser and navigating to the provided URL. From there, you can explore the various features and functionalities of CoFMPy's web interface.</p> <p>This web interface is still under development, and additional features and improvements will be added in the future.</p>"},{"location":"#python-interface","title":"\ud83d\udc0d Python interface","text":"<p>The Python interface allows users to use CoFMPy in a more granular way. A high-level API is provided to reproduce the same functionalities as the graphical interface. Advanced users can also dive deeper into the structure of CoFMPy for a more advanced control of the components.</p> <p>Under the hood, CoFMPy is controlled by a component called the Coordinator. It is the entry point of CoFMPy and it manages all the other components:</p> <ul> <li>the Master algorithm which is the engine that runs the co-simulation of FMUs.</li> <li>the Graph Engine that builds the connections and interactions between the FMUs and the   data sources and sinks.</li> <li>the data stream handlers that control the input data required by the co-simulation   system.</li> <li>the data storages that allow to store or send the outputs of the simulation.</li> <li>the GUI as the frontend of CoFMPy.</li> </ul>"},{"location":"#json-configuration-file","title":"\ud83d\udcdc JSON configuration file","text":"<p>To properly define the co-simulation system, a JSON configuration file must be created. This file is the only information required by CoFMPy to run the simulation. It must respect a specific syntax in order to define the FMUs, the interactions between them, the data sources and sinks, etc.</p>"},{"location":"#contributing","title":"\u2712\ufe0f Contributing","text":"<p>Feel free to propose your ideas or come and contribute with us on the CoFMPy library!</p>"},{"location":"#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>This project was funded by the European Union under GA no 101101961 - HECATE. Views and opinions expressed are however those of the authors only and do not necessarily reflect those of the European Union or Clean Aviation Joint Undertaking. Neither the European Union nor the granting authority can be held responsible for them. The project is supported by the Clean Aviation Joint Undertaking and its Members.</p>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>The package is released under MIT license.</p>"},{"location":"contributing/","title":"\u2712\ufe0f Contributing to CoFMPy","text":"<p>First off, thank you for considering contributing to CoFMPy! By contributing, you help improve this project and make it available to many others. We welcome contributions in various forms, whether it\u2019s through code, documentation, bug reports, or feature suggestions.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":"<p>We appreciate all kinds of contributions. Whether you find bugs, want to improve documentation, or implement new features, there are several ways you can contribute.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you find a bug or unexpected behavior, please follow these steps: 1. Search the existing issues to check if it has already been reported. 2. If it's a new issue, create a new issue with the following information:    - A clear description of the problem.    - Steps to reproduce the issue (if possible).    - Your environment details (e.g., operating system, Python version).    - Error messages or logs, if any.</p>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>We love hearing about new ideas for features or improvements! To suggest a feature: 1. Search to see if someone else has already suggested it. 2. If it's not already suggested, create a new issue to describe the enhancement:    - A clear explanation of the feature and its use cases.    - Why it would be valuable to the project.    - If applicable, any examples of how the feature might work.</p>"},{"location":"contributing/#submitting-code","title":"Submitting Code","text":"<p>We welcome code contributions! If you want to submit code, please follow the steps below.</p> <ol> <li>Fork the repository and clone your fork to your local machine.</li> <li>Create a new branch for your changes. Try to name it meaningfully, such as    <code>fix/bug-description</code> or <code>feature/feature-name</code>.</li> <li>Make your changes. Ensure that your changes don't break the existing    functionality. Follow Pylint style guidelines.</li> <li>Write tests to cover your changes, if applicable. See the Testing    section for more details.</li> <li>Commit your changes with a descriptive commit message (see the    Commit Messages section).</li> <li>Push your branch to your fork on GitHub.</li> <li>Open a Pull Request (PR) with a clear description of your changes.</li> </ol>"},{"location":"contributing/#setup-installation-for-developers","title":"Setup Installation for Developers","text":"<p>To get started with contributing to this project, you'll need to set up your development environment.</p> <ol> <li>Clone the repo: <code>git clone https://github.com/blabla/cofmpy.git</code></li> <li>Go to the root of the repo: <code>cd cofmpy</code></li> <li> <p>Create a new virtual environement:</p> <ul> <li>using <code>venv</code> on Linux:</li> </ul> <pre><code>python3 -m venv env_cofmpy\nsource env_cofmpy/bin/activate\n</code></pre> <ul> <li>using <code>venv</code> on Windows:</li> </ul> <pre><code>python3 -m venv env_cofmpy\nenv_cofmpy/Scripts/activate.bat\n</code></pre> <ul> <li>using <code>conda</code>:</li> </ul> <pre><code>conda create -n env_cofmpy python=3.10\nconda activate env_cofmpy\n</code></pre> </li> <li> <p>Install dependencies using <code>pip</code>:</p> </li> </ol> <pre><code>pip install -U pip\npip install -r requirements.txt -r requirements_dev.txt\npip install -e .\n</code></pre> <p>Your environment is now ready for development! You can run <code>pytest</code>\u00a0to verify that the environment is set up correctly.</p>"},{"location":"contributing/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Write clear, concise code that follows Python best practices.</li> <li>Ensure that your code is compatible with Python 3.9+.</li> <li>Document your code with docstrings, especially for functions, classes, and   modules.</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write tests for your changes (if applicable). We use pytest for   testing, so please ensure your code passes the existing tests as well as any new ones.</li> <li>To run CI tests locally, use either:</li> <li><code>tox</code> environments, e.g. <code>tox -e py310-lint</code> for format/lint checks and <code>tox -e     py310</code> for pytest unit tests.</li> <li>or directly using <code>black</code>, <code>pylint</code> and <code>pytest</code>:</li> </ul> <pre><code>python -m black --check --diff\npython -m pylint cofmpy\npytest\n</code></pre>"},{"location":"contributing/#generating-documentation","title":"Generating Documentation","text":"<p>The documentation is generated with MkDocs. From the root of the repo, you can generate the documentation and run the live server with:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started with CoFMPy","text":"<p>CoFMPy is a framework designed to make co-simulation easy and efficient. This guide walks you through setting up and running a your first simulation with CoFMPy!</p>"},{"location":"getting_started/#installation","title":"\ud83d\udc3e Installation","text":"<p>Before you begin, ensure CoFMPy is installed:</p> <pre><code>pip install cofmpy\n</code></pre>"},{"location":"getting_started/#running-your-first-simulation","title":"\ud83d\udcbb Running Your First Simulation","text":"<p>With CoFMPy, you can simulate complex systems composed of multiple FMUs connected together. You can even integrate external files or network interfaces. For now, we will keep it simple and consider the system consisting of an alternating voltage source and a resistor, as shown in the figure below: </p> <ul> <li>The source outputs a voltage signal, denoted as \\(V\\) (in Volts).</li> <li>The resistor takes \\(V\\) as input and produces an output current \\(I\\) (in Amperes). The resistance parameter \\(R\\) is set to \\(0.5\\) \\Omega$.</li> </ul> <p>We've already prepared FMUs and configuration file associated to this scenario. Let's start by downloading them.</p> <pre><code>import os\nimport requests\nimport zipfile\n\nurl = \"https://share-is.pf.irt-saintexupery.com/s/39zaG9HkQWnePbi/download\"\n# Local path to ressources folder\nressources_path = \"example1.zip\"  #\n# Download the file\nresponse = requests.get(url, stream=True)\nwith open(ressources_path, \"wb\") as f:\n    for chunk in response.iter_content(chunk_size=8192):\n        f.write(chunk)\n    print(f\"Ressources downloaded as {ressources_path}.\")\n# Unzip the file\nwith zipfile.ZipFile(\"example1.zip\", \"r\") as zip_ref:\n    zip_ref.extractall(\".\")\n# remove the zip file\nos.remove(ressources_path)\nprint(\"Ressources unzipped in example1 folder!\")\n</code></pre>"},{"location":"getting_started/#step-1-instantiate-the-coordinator","title":"Step 1: Instantiate the Coordinator","text":"<p>The heart of CoFMPy is the <code>Coordinator</code>, which is responsible for managing the simulation process. We begin by instantiating it and loading the configuration file just downloaded above:</p> <pre><code># Import the main CoFMPy component\nfrom cofmpy import Coordinator\n\n# Create an instance of the Coordinator\ncoordinator = Coordinator()\n\n# Load the simulation setup from a JSON configuration file\ncoordinator.start(\"example1/config.json\")\n</code></pre> <p>To make sure your simulation is correctly set up, you can visualize the connection graph of your system:</p> <pre><code># Display a graphical representation of the simulated system\ngraph = coordinator.graph_engine.plot_graph()\ngraph.show()\n</code></pre>"},{"location":"getting_started/#step-2-execute-a-simulation-step-or-run-it-until-completion","title":"Step 2: Execute a Simulation Step or run it until completion","text":"<p>Here, you can either execute the simulation step by step or run it until completion.</p> <pre><code># Define the time step for the simulation\nstep_size = 0.05\n\n# Run a single step of the simulation\ncoordinator.do_step(step_size)\n\n# Print the current time in the simulation\nprint(f\"Current simulation time: {coordinator.master.current_time}\")\n\n# Alternatively, run the co-simulation until a specified end time\nend_time = 0.5\ncoordinator.run_simulation(step_size, end_time)\nprint(\"Simulation completed!\")\n</code></pre>"},{"location":"getting_started/#step-3-access-results","title":"Step 3: Access Results","text":"<p>Once the simulation is finished, you can retrieve and inspect the results.</p> <pre><code># Retrieve stored simulation results\nresults = coordinator.get_results()\n\n# Display a preview of the results\nprint(results[(\"source\", \"V\")])\nprint(results[(\"resistor\", \"I\")])\n</code></pre>"},{"location":"getting_started/#whats-next","title":"\u23ed What\u2019s Next?","text":"<ul> <li>Try modifying the configuration file to explore different scenarios.</li> <li>Experiment with different step sizes to see how they affect results.</li> <li>Explore CoFMPy's examples gallery.</li> <li>Dive deeper into advanced features by checking the official documentation.</li> </ul>"},{"location":"api/","title":"API documentation","text":"<p>This is the API documentation blabla</p>"},{"location":"api/#end-user-documentation","title":"End-user documentation","text":"<p>As an end user, we suggest to start with the main object in CoFMPy: the Coordinator.</p>"},{"location":"api/#developer-documentation","title":"Developer documentation","text":"<p>As a developer, you may need to implement your own blocks, e.g. a custom data stream handler. In this case, you must follow the same interface as the objects already provided in CoFMPy: inheritance, abstract methods and members, etc.</p>"},{"location":"api/config_parser/","title":"The Parser for Configuration File","text":"<p>This module is designed to parse, validate, and structure a JSON configuration file for the co-simulation framework. It ensures that all necessary configurations for GraphEngine, Master DataStreamHandlers, and DataStorages are correctly formatted and ready for execution. Additionally, it performs sanity checks to detect missing keys, redundant endpoints, and orphaned connections.</p>"},{"location":"api/config_parser/#cofmpy.config_parser.ConfigParser","title":"ConfigParser","text":"<pre><code>ConfigParser(\n    file_path, edge_sep=\" -&gt; \", loop_solver=\"jacobi\"\n)\n</code></pre> <p>Parses and validates JSON configuration files.</p> <p>This class handles loading, validation, and transformation of configuration data for various components such as the Graph Engine, Master Solver, Data Storages, and Stream Handlers.</p> ATTRIBUTE DESCRIPTION <code>file_path</code> <p>Path to the configuration file. Can also be a dictionary if the user prefers to provide the configuration directly without using a JSON file.</p> <p> TYPE: <code>Union[str, Dict]</code> </p> <code>edge_sep</code> <p>Edge separator for connections. Defaults to \" -&gt; \".</p> <p> TYPE: <code>str</code> </p> <code>loop_solver</code> <p>Method used to solve algebrauc loops. Defaults to \"jacobi\".</p> <p> TYPE: <code>str</code> </p> <code>config_dict</code> <p>The parsed configuration dictionary.</p> <p> TYPE: <code>Dict</code> </p> <code>graph_config</code> <p>Configuration for the graph engine.</p> <p> TYPE: <code>Dict</code> </p> <code>master_config</code> <p>Configuration for the master solver.</p> <p> TYPE: <code>Dict</code> </p> <code>data_storages</code> <p>Storage settings for external data.</p> <p> TYPE: <code>Dict</code> </p> <code>stream_handlers</code> <p>Handlers for external data streams.</p> <p> TYPE: <code>Dict</code> </p> <code>error_in_config</code> <p>Indicates whether errors exist in the configuration.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>cofmpy/config_parser.py</code> <pre><code>def __init__(\n    self,\n    file_path: Union[str, Dict],\n    edge_sep: str = \" -&gt; \",\n    loop_solver: str = \"jacobi\",\n) -&gt; None:\n    # Arguments\n    self.file_path = file_path\n    self.loop_solver = loop_solver\n    self.edge_sep = edge_sep\n\n    self.config_dict: Dict = {}\n    self.graph_config: Dict = {}\n    self.master_config: Dict = {}\n    self.data_storages: Dict = {}\n    self.stream_handlers: Dict = {}\n    self.error_in_config: bool = False\n\n    # ------------ 1. Load config: self.config_dict ------------------\n    self.config_dict = self._load_config(file_check=True)\n\n    # ------------ 2. Apply defaults and perform validation ------------\n    self._apply_defaults(edge_sep, loop_solver)\n    self._validate_configuration()\n\n    # ------------ 3. Prepend 'root' dir to present paths ------------\n    self._update_paths_in_dict()\n\n    # ------------ 4. Build configurations ---------------------------\n    self._build_master_config()\n    self._build_handlers_config()\n    self._build_graph_config()\n</code></pre>"},{"location":"api/coordinator/","title":"Coordinator","text":"<p>The Coordinator is the main class in CoFMPy. It controls the blocks internally in order to ease the usage of the library. For end users, this is the only interface to start with: from a JSON configuration file, the coordinator will instantiate and monitor all the required components.</p> <pre><code>from cofmpy import Coordinator\n\n# Instantiate the Coordinator\nmy_coordinator = Coordinator()\n\n# Start the Coordinator (and all its components) from a JSON configuration file\nmy_coordinator.start(conf_path=\"my_config_file.json\")\n</code></pre> <p>The Coordinator can then run the simulation using <code>do_step()</code> or <code>run_simulation()</code>. Internally, the Master component will execute the steps of the co-simulation.</p> <pre><code>n_steps = 100\nfor _ in range(N):\n    my_coordinator.do_step(step_size=0.05)\n</code></pre> <p>It is then possible to get the simulation results as a Pandas dataframe :</p> <pre><code>results_df = my_coordinator.get_results()\n</code></pre> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def __init__(self):\n    self.config_parser = None\n    self.graph_engine = None\n    self.master = None\n    self.stream_handlers = None\n    self.data_storages = None\n\n    self.config_data = None\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.do_step","title":"do_step","text":"<pre><code>do_step(step_size: float, save_data=False)\n</code></pre> <p>Perform a simulation step.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>simulation step size</p> <p> TYPE: <code>float</code> </p> <code>save_data</code> <p>whether to save the data in the default CSV data storage. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def do_step(self, step_size: float, save_data=False):\n    \"\"\"\n    Perform a simulation step.\n\n    Args:\n        step_size (float): simulation step size\n        save_data (bool): whether to save the data in the default CSV data storage.\n            Defaults to False.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    # Get data from inbound data stream handlers\n    data = {\n        key: handler.get_data(self.master.current_time)\n        for key, handler in self.stream_handlers.items()\n    }\n    data_for_master = self._dict_tuple_to_dict_of_dict(data)\n\n    # Do step in the master\n    outputs = self.master.do_step(step_size, input_dict=data_for_master)\n\n    # Save results and data\n    if save_data:\n        results = [self.master.current_time]\n        for _, fmu_output_dict in outputs.items():\n            for _, output_value in fmu_output_dict.items():\n                results.append(output_value[0])\n        for d in data.values():\n            results.append(d)\n        self.data_storages[\"results\"].save(\"results\", [results])\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.get_causality","title":"get_causality","text":"<pre><code>get_causality(name: tuple) -&gt; str\n</code></pre> <p>Gets the causality of the given variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>str</code> <p>causality of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def get_causality(self, name: tuple) -&gt; str:\n    \"\"\"\n    Gets the causality of the given variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        str: causality of the variable.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    fmu_id, var_name = name\n    return self.master.fmu_handlers[fmu_id].get_causality(var_name)\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.get_results","title":"get_results","text":"<pre><code>get_results()\n</code></pre> <p>Get the results from the simulation.</p> RETURNS DESCRIPTION <p>pd.DataFrame: dataframe with the results.</p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def get_results(self):\n    \"\"\"\n    Get the results from the simulation.\n\n    Returns:\n        pd.DataFrame: dataframe with the results.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n    return self.master.get_results()\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.get_variable","title":"get_variable","text":"<pre><code>get_variable(name: tuple)\n</code></pre> <p>Get the value of the given tuple fmu/variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <p>value of the variable.</p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def get_variable(self, name: tuple):\n    \"\"\"\n    Get the value of the given tuple fmu/variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        value of the variable.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    fmu_id, var_name = name\n    return self.master.fmu_handlers[fmu_id].get_variable(var_name)\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.get_variable_names","title":"get_variable_names","text":"<pre><code>get_variable_names() -&gt; list\n</code></pre> <p>Get the names of all variables in the system.</p> RETURNS DESCRIPTION <code>list</code> <p>list of variable names as (fmu_id, var_name) tuples.</p> <p> TYPE: <code>list</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def get_variable_names(self) -&gt; list:\n    \"\"\"\n    Get the names of all variables in the system.\n\n    Returns:\n        list: list of variable names as (fmu_id, var_name) tuples.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    var_names = []\n    for fmu_id, fmu in self.master.fmu_handlers.items():\n        var_names += [(fmu_id, var) for var in fmu.get_variable_names()]\n\n    return var_names\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.get_variable_type","title":"get_variable_type","text":"<pre><code>get_variable_type(name: tuple) -&gt; str\n</code></pre> <p>Get the type of the given variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>variable name as (fmu_id, var_name).</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>str</code> <p>type of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def get_variable_type(self, name: tuple) -&gt; str:\n    \"\"\"\n    Get the type of the given variable.\n\n    Args:\n        name (tuple): variable name as (fmu_id, var_name).\n\n    Returns:\n        str: type of the variable.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    fmu_id, var_name = name\n    return self.master.fmu_handlers[fmu_id].get_variable_type(var_name)\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.get_variables","title":"get_variables","text":"<pre><code>get_variables(names: list) -&gt; dict\n</code></pre> <p>Get the values of the given variables.</p> PARAMETER DESCRIPTION <code>names</code> <p>list of variable names as (fmu_id, var_name) to get, e.g. [(\"fmu1\", \"var3\"), (\"fmu2\", \"var1\")].</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>dictionary with the variable names and their values.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def get_variables(self, names: list) -&gt; dict:\n    \"\"\"\n    Get the values of the given variables.\n\n    Args:\n        names (list): list of variable names as (fmu_id, var_name) to get,\n            e.g. [(\"fmu1\", \"var3\"), (\"fmu2\", \"var1\")].\n\n    Returns:\n        dict: dictionary with the variable names and their values.\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    var_values = {}\n    for name in names:\n        var_values[name] = self.get_variable(name)\n\n    return var_values\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.load_data_storages","title":"load_data_storages","text":"<pre><code>load_data_storages(data_storages_config: dict)\n</code></pre> <p>Load the data storages from the given dictionary of configurations.</p> PARAMETER DESCRIPTION <code>data_storages</code> <p>dictionary containing the configurations for the data storages.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def load_data_storages(self, data_storages_config: dict):\n    \"\"\"\n    Load the data storages from the given dictionary of configurations.\n\n    Args:\n        data_storages (dict): dictionary containing the configurations for the\n            data storages.\n    \"\"\"\n    self.data_storages = {\n        key: BaseDataStorage.create_data_storage(config)\n        for key, config in data_storages_config.items()\n    }\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.load_stream_handlers","title":"load_stream_handlers","text":"<pre><code>load_stream_handlers(stream_handlers_config: dict)\n</code></pre> <p>Load the stream handlers from the given dictionary of configurations.</p> PARAMETER DESCRIPTION <code>stream_handlers</code> <p>dictionary containing the configurations for the stream handlers.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def load_stream_handlers(self, stream_handlers_config: dict):\n    \"\"\"\n    Load the stream handlers from the given dictionary of configurations.\n\n    Args:\n        stream_handlers (dict): dictionary containing the configurations for the\n            stream handlers.\n    \"\"\"\n    self.stream_handlers = {\n        key: BaseDataStreamHandler.create_handler(config)\n        for key, config in stream_handlers_config.items()\n    }\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.parse_config","title":"parse_config","text":"<pre><code>parse_config(config_path: str)\n</code></pre> <p>Start the configuration parser to parse the given configuration file.</p> PARAMETER DESCRIPTION <code>config_path</code> <p>path to the configuration file</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def parse_config(self, config_path: str):\n    \"\"\"\n    Start the configuration parser to parse the given configuration file.\n\n    Args:\n        config_path (str): path to the configuration file\n    \"\"\"\n\n    self.config_parser = ConfigParser(config_path)\n    self.config_data = self.config_parser.config_dict\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.run_simulation","title":"run_simulation","text":"<pre><code>run_simulation(step_size: float, end_time: float)\n</code></pre> <p>Run the simulation until the given end time.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>simulation step size</p> <p> TYPE: <code>float</code> </p> <code>end_time</code> <p>simulation end time</p> <p> TYPE: <code>float</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def run_simulation(self, step_size: float, end_time: float):\n    \"\"\"\n    Run the simulation until the given end time.\n\n    Args:\n        step_size (float): simulation step size\n        end_time (float): simulation end time\n    \"\"\"\n    if self.master is None:\n        raise RuntimeError(\"Coordinator not initialized. Call start() first.\")\n\n    while self.master.current_time &lt; end_time:\n        self.do_step(step_size)\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.save_results","title":"save_results","text":"<pre><code>save_results(filename: str)\n</code></pre> <p>Save the results to a CSV file.</p> PARAMETER DESCRIPTION <code>filename</code> <p>name of the CSV file to save the results to.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def save_results(self, filename: str):\n    \"\"\"\n    Save the results to a CSV file.\n\n    Args:\n        filename (str): name of the CSV file to save the results to.\n    \"\"\"\n    df_results = pd.DataFrame.from_dict(self.get_results())\n\n    # Sort the columns starting with \"time\" and then alphabetically\n    columns = df_results.columns.tolist()\n    columns.remove(\"time\")\n    columns = [\"time\"] + sorted(columns)\n\n    # Set headers of the CSV file where tuple (fmu, var_name) is replaced by\n    # \"fmu.var_name\"\n    headers = list(columns)  # copy of the mutable list\n    for i, col_header in enumerate(headers):\n        if isinstance(col_header, tuple):\n            headers[i] = f\"{col_header[0]}.{col_header[1]}\"\n\n    df_results.to_csv(filename, columns=columns, header=headers, index=False)\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.start","title":"start","text":"<pre><code>start(\n    conf_path: str,\n    fixed_point_init=False,\n    fixed_point_kwargs=None,\n)\n</code></pre> <p>Start the coordinator with the given configuration file.</p> PARAMETER DESCRIPTION <code>conf_path</code> <p>path to the configuration file.</p> <p> TYPE: <code>str</code> </p> <code>fixed_point_init</code> <p>whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fixed_point_kwargs</code> <p>keyword arguments for the fixed point initialization method if fixed_point is set to True. Defaults to None, in which case the default values are used \"solver\": \"fsolve\", \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def start(self, conf_path: str, fixed_point_init=False, fixed_point_kwargs=None):\n    \"\"\"\n    Start the coordinator with the given configuration file.\n\n    Args:\n        conf_path (str): path to the configuration file.\n        fixed_point_init (bool): whether to use the fixed-point initialization method.\n        fixed_point_kwargs (dict): keyword arguments for the fixed point initialization\n            method if fixed_point is set to True. Defaults to None, in which\n            case the default values are used \"solver\": \"fsolve\",\n            \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.\n    \"\"\"\n\n    # 1. Start ConfigParser and parse the configuration file\n    self.parse_config(conf_path)\n\n    # print(self.config_parser.config_dict)\n\n    # 2. Start GraphEngine\n    self.start_graph_engine(self.config_parser.graph_config)\n\n    # 3. Start Master\n    self.config_parser.master_config[\"sequence_order\"] = (\n        self.graph_engine.sequence_order\n    )\n    self.start_master(\n        self.config_parser.master_config,\n        fixed_point_init=fixed_point_init,\n        fixed_point_kwargs=fixed_point_kwargs,\n    )\n\n    # 4. Create DataStreamHandlers\n    self.load_stream_handlers(self.config_parser.stream_handlers)\n\n    # 5. Create DataStorages\n    self.load_data_storages(self.config_parser.data_storages)\n\n    # 6. Save all results in a CSV file (additional data storage)\n    self.data_storages[\"results\"] = BaseDataStorage.create_data_storage(\n        {\n            \"type\": \"file\",\n            \"config\": {\"output_dir\": \"./storage\", \"overwrite\": True},\n        }\n    )\n    # write the header for the results file\n    output_names = []\n    for fmu_id, outputs in self.master.get_outputs().items():\n        for output_name in outputs:\n            output_names.append(f\"{fmu_id}.{output_name}\")\n    for stream in self.stream_handlers:\n        output_names.append(f\"{stream[0]}.{stream[1]}\")\n    self.data_storages[\"results\"].save(\"results\", [[\"t\"] + output_names])\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.start_graph_engine","title":"start_graph_engine","text":"<pre><code>start_graph_engine(config: dict)\n</code></pre> <p>Start the graph engine with the given configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration for the graph engine containing the FMUs, connections, and edge separation.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def start_graph_engine(self, config: dict):\n    \"\"\"\n    Start the graph engine with the given configuration.\n\n    Args:\n        config (dict): configuration for the graph engine containing the FMUs,\n            connections, and edge separation.\n    \"\"\"\n    self.graph_engine = GraphEngine(\n        config[\"fmus\"],\n        config[\"symbolic_nodes\"],\n        config[\"connections\"],\n        config[\"edge_sep\"],\n    )\n</code></pre>"},{"location":"api/coordinator/#cofmpy.coordinator.Coordinator.start_master","title":"start_master","text":"<pre><code>start_master(\n    config: dict,\n    fixed_point_init=False,\n    fixed_point_kwargs=None,\n)\n</code></pre> <p>Start the master algorithm with the given configuration.</p> PARAMETER DESCRIPTION <code>config</code> <p>configuration for the master algorithm containing the FMUs, connections, sequence order, and loop method.</p> <p> TYPE: <code>dict</code> </p> <code>fixed_point_init</code> <p>whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>fixed_point_kwargs</code> <p>keyword arguments for the fixed point initialization method if fixed_point is set to True. Defaults to None, in which case the default values are used \"solver\": \"fsolve\", \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> Source code in <code>cofmpy/coordinator.py</code> <pre><code>def start_master(\n    self, config: dict, fixed_point_init=False, fixed_point_kwargs=None\n):\n    \"\"\"\n    Start the master algorithm with the given configuration.\n\n    Args:\n        config (dict): configuration for the master algorithm containing the FMUs,\n            connections, sequence order, and loop method.\n        fixed_point_init (bool): whether to use the fixed-point initialization method.\n        fixed_point_kwargs (dict): keyword arguments for the fixed point initialization\n            method if fixed_point is set to True. Defaults to None, in which\n            case the default values are used \"solver\": \"fsolve\",\n            \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.\n    \"\"\"\n    self.master = Master(\n        fmu_config_list=config[\"fmus\"],\n        connections=config[\"connections\"],\n        sequence_order=config[\"sequence_order\"],\n        loop_solver=config[\"loop_solver\"],\n        fixed_point=fixed_point_init,\n        fixed_point_kwargs=fixed_point_kwargs,\n    )\n    self.master.init_simulation(input_dict={})\n</code></pre>"},{"location":"api/graph_engine/","title":"The Cosimulation Graph Engine","text":"<p>GraphEngine is a class that represents a graph structure based on * FMUs and/or symbolic nodes * connections (namely edges) It uses networkx library to build and manipulate the graph.</p> <p>Custom dependencies: the method plot_graph uses GraphPlotter</p> <p>Initialize the GraphEngine instance, set up the FMU and connection lists, and construct the graph.</p> PARAMETER DESCRIPTION <code>fmu_list</code> <p>List of FMU data (each FMU represented as a dictionary).</p> <p> TYPE: <code>List[Dict]</code> </p> <code>symbolic_nodes</code> <p>List of symbolic nodes (each node represented as a dictionary).</p> <p> TYPE: <code>List[Dict]</code> </p> <code>conn_list</code> <p>List of connections (each connection represented as a dictionary).</p> <p> TYPE: <code>List[Dict]</code> </p> <code>edge_sep</code> <p>Separator used for edge labels. Default is \" -&gt; \".</p> <p> TYPE: <code>str</code> DEFAULT: <code>' -&gt; '</code> </p> Source code in <code>cofmpy/graph_engine.py</code> <pre><code>def __init__(\n    self,\n    fmu_list: List[Dict],\n    symbolic_nodes: List[Dict],\n    conn_list: List[Dict],\n    edge_sep: str = \" -&gt; \",\n) -&gt; None:\n    \"\"\"\n    Initialize the GraphEngine instance, set up the FMU and connection lists,\n    and construct the graph.\n\n    Args:\n        fmu_list (List[Dict]): List of FMU data (each FMU represented as a\n            dictionary).\n        symbolic_nodes (List[Dict]): List of symbolic nodes (each node represented\n            as a dictionary).\n        conn_list (List[Dict]): List of connections (each connection represented as\n            a dictionary).\n        edge_sep (str, optional): Separator used for edge labels.\n            Default is \" -&gt; \".\n    \"\"\"\n\n    self.fmu_list = fmu_list\n    self.symbolic_nodes = symbolic_nodes\n    self.conn_list = conn_list\n    self.edge_sep = edge_sep\n    self.keys = Keys()\n    self.color_map = {}\n\n    # Build Graph\n    self.graph, self.fmu_types = self._create_graph()\n\n    # Create connections and get order\n    self.connections = self._name_connections()\n    self.sequence_order = self._get_order()\n</code></pre>"},{"location":"api/graph_engine/#cofmpy.graph_engine.GraphEngine.plot_graph","title":"plot_graph","text":"<pre><code>plot_graph(savefig=False)\n</code></pre> <p>Plot a graph representation of the co-simulation diagram.</p> <p>This method generates a Plotly figure showing nodes and their connections. It uses NetworkX for node positioning and Plotly for rendering the graph.</p> PARAMETER DESCRIPTION <code>savefig</code> <p>Whether to save the figure as an HTML file. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Figure</code> <p>go.Figure: The Plotly figure object representing the co-simulation diagram.</p> Source code in <code>cofmpy/graph_engine.py</code> <pre><code>def plot_graph(self, savefig: bool = False) -&gt; go.Figure:\n    \"\"\"\n    Plot a graph representation of the co-simulation diagram.\n\n    This method generates a Plotly figure showing nodes and their connections.\n    It uses NetworkX for node positioning and Plotly for rendering the graph.\n\n    Args:\n        savefig (bool, optional): Whether to save the figure as an HTML file. Defaults to False.\n\n    Returns:\n        go.Figure: The Plotly figure object representing the co-simulation diagram.\n    \"\"\"\n\n    plotter = GraphPlotter()\n\n    size_map = {k: 1 if v == \"fmu\" else 0.2 for k, v in self.fmu_types.items()}\n\n    fig = plotter.generate_figure(\n        self.graph, self.fmu_list + self.symbolic_nodes, size_map\n    )\n\n    self.color_map = plotter.color_map\n\n    if savefig:\n        plotter.save_plotly_figure(fig, \"cosim_diagram\")\n\n    return fig\n</code></pre>"},{"location":"api/master/","title":"The Cosimulation Master","text":"<p>Module for managing and executing co-simulations involving multiple FMUs.</p> <p>This module provides a <code>Master</code> class that handles FMU initialization, input setting, stepping, and result collection during simulation.</p>"},{"location":"api/master/#cofmpy.master.Master","title":"Master","text":"<pre><code>Master(\n    fmu_config_list,\n    connections,\n    sequence_order,\n    loop_solver=\"jacobi\",\n    fixed_point=False,\n    fixed_point_kwargs=None,\n)\n</code></pre> <p>Manages and executes the co-simulation involving multiple FMUs.</p> ATTRIBUTE DESCRIPTION <code>fmu_config_list</code> <p>A list of dictionaries containing information about the FMUs to be used in the simulation.</p> <p> TYPE: <code>list</code> </p> <code>connections</code> <p>A dictionary of connections between FMUs. The keys are tuples (source_fmu, source_variable), and the values are dictionaries with information about the source and target FMUs and variables.</p> <p> TYPE: <code>dict</code> </p> <code>sequence_order</code> <p>The order in which FMUs should be executed.</p> <p> TYPE: <code>list</code> </p> <code>loop_solver</code> <p>The method used to solve algebraic loops in the simulation.</p> <p> TYPE: <code>str</code> </p> <code>current_time</code> <p>The current simulation time.</p> <p> TYPE: <code>float</code> </p> <code>fixed_point</code> <p>Whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> </p> <code>fixed_point_kwargs</code> <p>Keyword arguments for the fixed-point initialization method.</p> <p> TYPE: <code>dict</code> </p> METHOD DESCRIPTION <code>sanity_check</code> <p>Checks FMU compatibility, I/Os, and headers with the corresponding algorithm.</p> <code>set_inputs</code> <p>Sets the input values for the current simulation step using the provided input dictionary.</p> <code>init_simulation</code> <p>Initializes the simulation environment and FMUs.</p> <code>get_outputs</code> <p>Returns the output dictionary for the current step.</p> <code>get_results</code> <p>Returns the results of the simulation.</p> <code>solve_loop</code> <p>Uses the defined algorithm to solve algebraic loops in the simulation.</p> <code>do_step</code> <p>Performs a single step of the simulation, updating inputs, executing FMUs, and propagating outputs.</p> <p>Initializes the Master class with FMU configurations, connection details, sequence order, and loop solver.</p> PARAMETER DESCRIPTION <code>fmu_config_list</code> <p>List of dictionaries with FMU configurations.</p> <p> TYPE: <code>list</code> </p> <code>connections</code> <p>Dictionary mapping connections between FMUs.</p> <p> TYPE: <code>dict</code> </p> <code>sequence_order</code> <p>Execution order of FMUs.</p> <p> TYPE: <code>list</code> </p> <code>loop_solver</code> <p>Method for solving algebraic loops. Defaults to \"jacobi\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'jacobi'</code> </p> <code>fixed_point_init</code> <p>whether to use the fixed-point initialization method.</p> <p> TYPE: <code>bool</code> </p> <code>fixed_point_kwargs</code> <p>keyword arguments for the fixed point initialization method if fixed_point is set to True. Defaults to None, in which case the default values are used \"solver\": \"fsolve\", \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> Source code in <code>cofmpy/master.py</code> <pre><code>def __init__(\n    self,\n    fmu_config_list: list,\n    connections: dict,\n    sequence_order: list,\n    loop_solver: str = \"jacobi\",\n    fixed_point=False,\n    fixed_point_kwargs=None,\n):\n    \"\"\"\n    Initializes the Master class with FMU configurations, connection details,\n    sequence order, and loop solver.\n\n    Args:\n        fmu_config_list (list): List of dictionaries with FMU configurations.\n        connections (dict): Dictionary mapping connections between FMUs.\n        sequence_order (list): Execution order of FMUs.\n        loop_solver (str, optional): Method for solving algebraic loops. Defaults to\n            \"jacobi\".\n        fixed_point_init (bool): whether to use the fixed-point initialization method.\n        fixed_point_kwargs (dict): keyword arguments for the fixed point initialization\n            method if fixed_point is set to True. Defaults to None, in which\n            case the default values are used \"solver\": \"fsolve\",\n            \"time_step\": minimum_default_step_size, and \"xtol\": 1e-5.\n    \"\"\"\n\n    self.fmu_config_list = (\n        fmu_config_list  # List of FMU configurations (dict) from config file\n    )\n    self.connections = connections  # Dict of connections between FMUs\n\n    # Load FMUs into dict of FMU Handlers\n    self.fmu_handlers = self._load_fmus()\n\n    # Check if the names of the variables match between the connection dict and the FMUs\n    self._check_connections()\n\n    default_step_sizes = []\n    for fmu in self.fmu_handlers.values():\n        default_step_sizes.append(fmu.default_step_size)\n\n    ## find the smaller of all step sizes\n    # remove None from default_step_sizes\n    default_step_sizes = [x for x in default_step_sizes if x is not None]\n    if len(default_step_sizes) == 0:\n        self.default_step_size = 1.0\n    else:\n        self.default_step_size = np.min(default_step_sizes)\n\n    # Sequence order of execution as a List of FMU IDs. Extracted by config parser module\n    # Sequence order of execution as a List of FMU IDs. Extracted by config parser\n    self.sequence_order = sequence_order\n    if self.sequence_order is None:\n        self.sequence_order = [d[self.__keys[\"id\"]] for d in self.fmu_config_list]\n\n    # Loop solver method (default: Jacobi)\n    self.loop_solver = loop_solver\n    # init current_time to None to check if init_simulation() has been called\n    self.current_time = None\n    # Init output and input dictionaries for FMUs to maintain state between steps\n    # Initialize arrays for inputs and outputs\n    self._input_dict = {\n        fmu_id: np.zeros(len(fmu.get_input_names()))\n        for fmu_id, fmu in self.fmu_handlers.items()\n    }\n\n    self._output_dict = {\n        fmu_id: np.zeros(len(fmu.get_output_names()))\n        for fmu_id, fmu in self.fmu_handlers.items()\n    }\n    # Results dictionary to store the output values for each step\n    self._results = defaultdict(list)\n\n    self.fixed_point = fixed_point\n    self.fixed_point_kwargs = fixed_point_kwargs\n\n    if fixed_point and fixed_point_kwargs is None:\n        self.fixed_point_kwargs = {\n            \"solver\": \"fsolve\",\n            \"time_step\": self.default_step_size,\n            \"xtol\": 1e-5,\n        }\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.do_step","title":"do_step","text":"<pre><code>do_step(step_size, input_dict=None, record_outputs=True)\n</code></pre> <p>This method updates the input dictionary with the values from the provided input dictionary, performs a single step of the simulation on each FMU, using the solve_loop method, propagates the output values to the corresponding variables for the next step, and updates the current simulation time accordingly. It also stores the output values in the results dictionary.</p> PARAMETER DESCRIPTION <code>step_size</code> <p>The size of the simulation step.</p> <p> TYPE: <code>float</code> </p> <code>input_dict</code> <p>A dictionary containing input values for the simulation. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>record_outputs</code> <p>Whether to store the output values in the results dictionary. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the output values for this step, structured as [FMU_ID][Var].</p> Source code in <code>cofmpy/master.py</code> <pre><code>def do_step(self, step_size: float, input_dict=None, record_outputs=True):\n    \"\"\"\n    This method updates the input dictionary with the values from the provided input\n    dictionary, performs a single step of the simulation on each FMU, using the\n    solve_loop method, propagates the output values to the corresponding variables\n    for the next step, and updates the current simulation time accordingly. It also\n    stores the output values in the results dictionary.\n\n    Args:\n        step_size (float): The size of the simulation step.\n        input_dict (dict, optional): A dictionary containing input values for the\n            simulation. Defaults to None.\n        record_outputs (bool, optional): Whether to store the output values in the\n            results dictionary. Defaults to True.\n\n    Returns:\n        dict: A dictionary containing the output values for this step, structured as\n            [FMU_ID][Var].\n\n    \"\"\"\n    self.set_inputs(input_dict=input_dict)\n    for fmu_ids in self.sequence_order:\n        # out = {\"fmu_id\" : {\"output_name\" : value}}\n        out = self.solve_loop(fmu_ids, step_size, self.loop_solver)\n        for fmu_id, fmu_output_dict in out.items():\n            for output_name, value in fmu_output_dict.items():\n                # If output is connected, transfer the value to the connected FMU(s)\n                if (fmu_id, output_name) in self.connections:\n                    for target_fmu, target_variable in self.connections[\n                        (fmu_id, output_name)\n                    ]:\n                        self._input_dict[target_fmu][target_variable] = value\n\n                # add each output to the result dict, (FMU_ID + Var) as key\n                if record_outputs:\n                    self._results[(fmu_id, output_name)].extend(value)\n                # add each output to the output dict, [FMU_ID][Var] as key\n                self._output_dict[fmu_id][output_name] = value\n    if record_outputs:\n        self._results[\"time\"].append(self.current_time)\n    self.current_time += step_size\n    # Return the output value for this step\n    return self._output_dict\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.get_input_dict","title":"get_input_dict","text":"<pre><code>get_input_dict()\n</code></pre> <p>Returns the input dictionary for the current step.</p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the input values for the current step, structured as [fmu_id][variable_name] =&gt; list(value).</p> Source code in <code>cofmpy/master.py</code> <pre><code>def get_input_dict(self):\n    \"\"\"\n    Returns the input dictionary for the current step.\n\n    Returns:\n        dict: A dictionary containing the input values for the current step,\n            structured as [fmu_id][variable_name] =&gt; list(value).\n    \"\"\"\n    return self._input_dict\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.get_outputs","title":"get_outputs","text":"<pre><code>get_outputs()\n</code></pre> <p>Returns the output dictionary for the current step.</p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the output values of the current step, structured as [FMU_ID][Var].</p> <p> TYPE: <code>dict[str, list]</code> </p> Source code in <code>cofmpy/master.py</code> <pre><code>def get_outputs(self) -&gt; dict[str, list]:\n    \"\"\"\n    Returns the output dictionary for the current step.\n\n    Returns:\n        dict: A dictionary containing the output values of the current step,\n            structured as [FMU_ID][Var].\n    \"\"\"\n    return self._output_dict\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.get_results","title":"get_results","text":"<pre><code>get_results()\n</code></pre> <p>Returns the results of the simulation, this includes the values of every output variables, for each step, up until the current time of simulation.</p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionnary containing output values of every step, structured as [(FMU_ID, Var)]</p> Source code in <code>cofmpy/master.py</code> <pre><code>def get_results(self):\n    \"\"\"\n    Returns the results of the simulation, this includes the values of every output\n    variables, for each step, up until the current time of simulation.\n\n    Returns:\n        dict: A dictionnary containing output values of every step, structured as\n            [(FMU_ID, Var)]\n\n    \"\"\"\n    return self._results\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.init_simulation","title":"init_simulation","text":"<pre><code>init_simulation(input_dict=None)\n</code></pre> <p>Initializes the simulation environment and FMUs.</p> <p>This method sets up the necessary dictionaries for the simulation and initializes the FMUs with either a fixed point algorithm or values provided in the input dictionary.</p> PARAMETER DESCRIPTION <code>input_dict</code> <p>A dictionary containing input values for the simulation. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> The method performs the following steps <ol> <li>Sets the current simulation time to 0.</li> <li>If fixed_point is True, calls the _fixed_point_init() method.</li> <li>Otherwise, sets the inputs using the provided input_dict and initializes     each FMU with these values.</li> </ol> <p>Note: The FMUs are reset after setting the initial values.</p> Source code in <code>cofmpy/master.py</code> <pre><code>def init_simulation(self, input_dict=None):\n    \"\"\"\n    Initializes the simulation environment and FMUs.\n\n    This method sets up the necessary dictionaries for the simulation and\n    initializes the FMUs with either a fixed point algorithm or values provided in\n    the input dictionary.\n\n    Args:\n        input_dict (dict): A dictionary containing input values for the simulation.\n            Defaults to None.\n\n    The method performs the following steps:\n        1. Sets the current simulation time to 0.\n        2. If fixed_point is True, calls the _fixed_point_init() method.\n        3. Otherwise, sets the inputs using the provided input_dict and initializes\n            each FMU with these values.\n\n    **Note**: The FMUs are reset after setting the initial values.\n    \"\"\"\n\n    # # Init output and input dictionaries\n    for fmu_id, fmu in self.fmu_handlers.items():\n        self._output_dict[fmu_id] = {key: [0] for key in fmu.get_output_names()}\n        self._input_dict[fmu_id] = {key: [0] for key in fmu.get_input_names()}\n\n    # Init current_time of simulation to 0\n    self.current_time = 0.0\n\n    # Init input/output/parameter variables with the values provided in the config\n    self.initialize_values_from_config()\n\n    # INIT: call fixed_step()\n    if self.fixed_point:\n        print(\"Calling Fixed Point Initialization\")\n        self.set_inputs(input_dict=input_dict)\n        fixed_point_solver = FixedPointInitializer(self, **self.fixed_point_kwargs)\n        fixed_point_solution = fixed_point_solver.solve()\n        self.set_inputs(input_dict=fixed_point_solution)\n    else:\n        print(\"Skipping Fixed Point Initialization\")\n        self.set_inputs(input_dict=input_dict)\n\n    for fmu_id, fmu_handler in self.fmu_handlers.items():\n        init_dict = self._input_dict[fmu_id]\n        fmu_handler.set_variables(init_dict)\n        fmu_handler.reset()\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.initialize_values_from_config","title":"initialize_values_from_config","text":"<pre><code>initialize_values_from_config()\n</code></pre> <p>Initializes the FMU variables (inputs/outputs/parameters) with the values provided in the configuration dict.</p> <p>If the variable is an input, it is also added to the input dictionary</p> Source code in <code>cofmpy/master.py</code> <pre><code>def initialize_values_from_config(self):\n    \"\"\"\n    Initializes the FMU variables (inputs/outputs/parameters) with the values\n    provided in the configuration dict.\n\n    If the variable is an input, it is also added to the input dictionary\n    \"\"\"\n    if self.current_time is None:\n        raise RuntimeError(\n            \"Current time is not initialized. Call init_simulation() first.\"\n        )\n\n    for fmu in self.fmu_config_list:\n        fmu_handler = self.fmu_handlers[fmu[self.__keys[\"id\"]]]\n        for key, value in fmu[self.__keys[\"init\"]].items():\n            fmu_handler.set_variables({key: [value]})\n            if key in fmu_handler.get_input_names():\n                self._input_dict[fmu[self.__keys[\"id\"]]][key] = [value]\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.sanity_check","title":"sanity_check","text":"<pre><code>sanity_check()\n</code></pre> <p>Checks the compatibility of FMUs, including input/output validation and algorithm compliance.</p> Source code in <code>cofmpy/master.py</code> <pre><code>def sanity_check(self):  # TODO\n    \"\"\"\n    Checks the compatibility of FMUs, including input/output validation and\n    algorithm compliance.\n    \"\"\"\n    self._check_connections()\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.set_inputs","title":"set_inputs","text":"<pre><code>set_inputs(input_dict=None)\n</code></pre> <p>Sets the input values for the current simulation step.</p> <p>This method populates the internal input dictionary (<code>self._input_dict</code>) with values for the current step. It updates these values with those provided in the <code>input_dict</code> parameter, if given. The <code>input_dict</code> parameter is expected to be a dictionary of dictionaries, where each key is an FMU identifier and each value is another dictionary mapping variable names to their respective values (e.g., {\"FMU1\": {\"var1\": value}, \"FMU2\": {\"var2\": val, \"var3\": val}}).</p> PARAMETER DESCRIPTION <code>input_dict</code> <p>A dictionary of dictionaries containing input values to override the initialization values. Defaults to None.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the current simulation time (<code>self.current_time</code>) is not initialized. Ensure that init_simulation()` is called before invoking this method.</p> Source code in <code>cofmpy/master.py</code> <pre><code>def set_inputs(self, input_dict=None):\n    \"\"\"\n    Sets the input values for the current simulation step.\n\n    This method populates the internal input dictionary (`self._input_dict`) with\n    values for the current step. It updates these values with those provided in the\n    `input_dict` parameter, if given. The `input_dict` parameter is expected to be\n    a dictionary of dictionaries, where each key is an FMU identifier and each value\n    is another dictionary mapping variable names to their respective values (e.g.,\n    {\"FMU1\": {\"var1\": value}, \"FMU2\": {\"var2\": val, \"var3\": val}}).\n\n    Args:\n        input_dict (dict, optional): A dictionary of dictionaries containing input\n            values to override the initialization values. Defaults to None.\n\n    Raises:\n        RuntimeError: If the current simulation time (`self.current_time`) is not\n            initialized. Ensure that init_simulation()` is called before invoking\n            this method.\n    \"\"\"\n    if self.current_time is None:\n        raise RuntimeError(\n            \"Current time is not initialized. Call init_simulation() first.\"\n        )\n\n    if input_dict:  # True if input_dict is not empty\n        for fmu in input_dict:\n            if fmu not in self.fmu_handlers:\n                raise ValueError(\n                    f\"FMU '{fmu}' not found in FMUs: \"\n                    f\"{list(self.fmu_handlers.keys())}.\"\n                )\n            for variable in input_dict[fmu]:\n                if (\n                    variable\n                    not in self.fmu_handlers[fmu].get_input_names()\n                    + self.fmu_handlers[fmu].get_parameter_names()\n                ):\n                    raise ValueError(\n                        f\"Variable '{variable}' not found in inputs of FMU '{fmu}':\"\n                        f\" {self.fmu_handlers[fmu].get_input_names()}.\"\n                    )\n                # Set given values (will overide values set previously in init)\n                self._input_dict[fmu][variable] = input_dict[fmu][variable]\n</code></pre>"},{"location":"api/master/#cofmpy.master.Master.solve_loop","title":"solve_loop","text":"<pre><code>solve_loop(fmu_ids, step_size, algo='jacobi')\n</code></pre> <p>Performs a single simulation step on the given FMUs, using the defined algorithm to solve algebraic loops in the simulation.</p> <p>In the case there is no loop, the function will propagate the output values and return them.</p> PARAMETER DESCRIPTION <code>fmu_ids</code> <p>List of highly coupled FMUs. Contains only one FMU if there is no loop.</p> <p> TYPE: <code>list[str]</code> </p> <code>step_size</code> <p>The step size for data exchange (in cosimulation mode, FMU integration step is fixed).</p> <p> TYPE: <code>float</code> </p> <code>algo</code> <p>The algorithm to use to solve the loop (default: \"jacobi\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'jacobi'</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the output values for this step of the FMUs given, structured as [FMU_ID][Var]</p> Source code in <code>cofmpy/master.py</code> <pre><code>def solve_loop(self, fmu_ids, step_size: float, algo=\"jacobi\"):\n    \"\"\"\n    Performs a single simulation step on the given FMUs, using the defined algorithm\n    to solve algebraic loops in the simulation.\n\n    In the case there is no loop, the function will propagate the output values and\n    return them.\n\n    Args:\n        fmu_ids (list[str]): List of highly coupled FMUs. Contains only one FMU if\n            there is no loop.\n        step_size (float): The step size for **data exchange** (in cosimulation\n            mode, FMU integration step is fixed).\n        algo (str): The algorithm to use to solve the loop (default: \"jacobi\").\n\n    Returns:\n        dict: A dictionary containing the output values for this step of the FMUs\n            given, structured as [FMU_ID][Var]\n\n    \"\"\"\n\n    # TODO check FMU cosimulation mode and raise exception if it is model exchange\n\n    output = {}  # key: fmu_id, value: output_dict (var_name, value)\n    if algo == \"jacobi\":\n        for fmu_id in fmu_ids:\n            fmu = self.fmu_handlers[fmu_id]\n            output[fmu_id] = fmu.step(\n                self.current_time, step_size, self._input_dict[fmu_id]\n            )\n    else:\n        raise NotImplementedError(\n            f\"Algorithm {algo} not implemented for loop solving.\"\n        )\n\n    return output\n</code></pre>"},{"location":"api/wrappers/","title":"FMU Wrappers","text":"<p>FMU wrapper classes for FMI 2.0 and FMI 3.0.</p> <p>This module contains the FMU handler classes for FMI 2.0 and FMI 3.0. These classes are used to load FMU files and interact with loaded FMUs.</p>"},{"location":"api/wrappers/#cofmpy.wrappers.Fmu2Handler","title":"Fmu2Handler","text":"<pre><code>Fmu2Handler(path, fmu_slave)\n</code></pre> <p>               Bases: <code>FmuXHandler</code></p> <p>Handler class for FMU in FMI version 2.0.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def __init__(self, path: str, fmu_slave):\n    \"\"\"Initializes the FMU handler with the given path and FMU slave class.\n\n    Args:\n        path (str): The path of .fmu file to open\n        fmu_slave (class): The FMU slave class of FMPy to use to open the fmu\n    \"\"\"\n    # read the model description\n    self.description = read_model_description(path)\n\n    self.default_step_size = (\n        self.description.defaultExperiment.stepSize\n        if self.description.defaultExperiment\n        else None\n    )\n\n    # Create a dictionary to map variable names to attributes\n    self.var_name2attr = {}\n    for variable in self.description.modelVariables:\n        self.var_name2attr[variable.name] = variable\n\n    # extract the FMU and instantiate the slave\n    unzipdir = extract(path)\n    fmu_name = os.path.basename(path)\n\n    self.fmu = fmu_slave(\n        guid=self.description.guid,\n        unzipDirectory=unzipdir,\n        modelIdentifier=self.description.coSimulation.modelIdentifier,\n        instanceName=fmu_name,\n    )\n\n    # Get the output variable names\n    self.output_var_names = []\n    self.output_var_names = list(self.get_output_names())\n\n    # Instantiate the FMU\n    self.fmu.instantiate(loggingOn=False)\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.Fmu2Handler.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the FMU to its initial state and sets up the experiment.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the FMU to its initial state and sets up the experiment.\"\"\"\n    self.fmu.setupExperiment(startTime=0.0)\n    self.fmu.enterInitializationMode()\n    self.fmu.exitInitializationMode()\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.Fmu2Handler.step","title":"step","text":"<pre><code>step(current_time, step_size, input_dict)\n</code></pre> <p>Performs a simulation step with the given current time, step size, and input values.</p> PARAMETER DESCRIPTION <code>current_time</code> <p>the current simulation time.</p> <p> TYPE: <code>float</code> </p> <code>step_size</code> <p>the size of the simulation step.</p> <p> TYPE: <code>float</code> </p> <code>input_dict</code> <p>dictionary containing input variable names and their corresponding values.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <p>Dictionary containing output variable names and their corresponding values after the simulation step.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def step(self, current_time: float, step_size: float, input_dict: dict):\n    \"\"\"\n    Performs a simulation step with the given current time, step size, and input\n    values.\n\n    Args:\n        current_time (float): the current simulation time.\n        step_size (float): the size of the simulation step.\n        input_dict (dict): dictionary containing input variable names and their\n            corresponding values.\n\n    Returns:\n        Dictionary containing output variable names and their corresponding values\n            after the simulation step.\n    \"\"\"\n    # Set all the input variable that are given\n    for name, value in input_dict.items():\n        self.fmu.setReal([self.var_name2attr[name].valueReference], value)\n        # print(f\"{name} : {value}\")\n\n    self.fmu.doStep(\n        currentCommunicationPoint=current_time, communicationStepSize=step_size\n    )\n    result = {\n        name: self.fmu.getReal([self.var_name2attr[name].valueReference])\n        for name in self.get_output_names()\n    }\n    return result\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.Fmu3Handler","title":"Fmu3Handler","text":"<pre><code>Fmu3Handler(path, fmu_slave)\n</code></pre> <p>               Bases: <code>FmuXHandler</code></p> <p>Handler class for FMU in FMI version 3.0.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def __init__(self, path: str, fmu_slave):\n    \"\"\"Initializes the FMU handler with the given path and FMU slave class.\n\n    Args:\n        path (str): The path of .fmu file to open\n        fmu_slave (class): The FMU slave class of FMPy to use to open the fmu\n    \"\"\"\n    # read the model description\n    self.description = read_model_description(path)\n\n    self.default_step_size = (\n        self.description.defaultExperiment.stepSize\n        if self.description.defaultExperiment\n        else None\n    )\n\n    # Create a dictionary to map variable names to attributes\n    self.var_name2attr = {}\n    for variable in self.description.modelVariables:\n        self.var_name2attr[variable.name] = variable\n\n    # extract the FMU and instantiate the slave\n    unzipdir = extract(path)\n    fmu_name = os.path.basename(path)\n\n    self.fmu = fmu_slave(\n        guid=self.description.guid,\n        unzipDirectory=unzipdir,\n        modelIdentifier=self.description.coSimulation.modelIdentifier,\n        instanceName=fmu_name,\n    )\n\n    # Get the output variable names\n    self.output_var_names = []\n    self.output_var_names = list(self.get_output_names())\n\n    # Instantiate the FMU\n    self.fmu.instantiate(loggingOn=False)\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.Fmu3Handler.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Resets the FMU to its initial state</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def reset(self):\n    \"\"\"Resets the FMU to its initial state\"\"\"\n    self.fmu.enterInitializationMode()\n    self.fmu.exitInitializationMode()\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.Fmu3Handler.step","title":"step","text":"<pre><code>step(current_time, step_size, input_dict)\n</code></pre> <p>Performs a simulation step with the given current time, step size, and input values.</p> PARAMETER DESCRIPTION <code>current_time</code> <p>the current simulation time.</p> <p> TYPE: <code>float</code> </p> <code>step_size</code> <p>the size of the simulation step.</p> <p> TYPE: <code>float</code> </p> <code>input_dict</code> <p>dictionary containing input variable names and their corresponding values.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <p>Dictionary containing output variable names and their corresponding values after the simulation step.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def step(self, current_time: float, step_size: float, input_dict: dict):\n    \"\"\"\n    Performs a simulation step with the given current time, step size, and input\n    values.\n\n    Args:\n        current_time (float): the current simulation time.\n        step_size (float): the size of the simulation step.\n        input_dict (dict): dictionary containing input variable names and their\n            corresponding values.\n\n    Returns:\n        Dictionary containing output variable names and their corresponding values\n            after the simulation step.\n    \"\"\"\n    # Set all the input variable that are given\n    for name, value in input_dict.items():\n        if self.var_name2attr[name].type == \"Boolean\":\n            self.fmu.setBoolean([self.var_name2attr[name].valueReference], value)\n        else:\n            self.fmu.setFloat64([self.var_name2attr[name].valueReference], value)\n        # print(f\"{name} : {value}\")\n\n    self.fmu.doStep(\n        currentCommunicationPoint=current_time, communicationStepSize=step_size\n    )\n    result = {\n        name: self.fmu.getFloat64([self.var_name2attr[name].valueReference])\n        for name in self.output_var_names\n    }\n    return result\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuHandlerFactory","title":"FmuHandlerFactory","text":"<pre><code>FmuHandlerFactory(path)\n</code></pre> <p>Factory class to create FMU handlers based on the FMI version.</p> ATTRIBUTE DESCRIPTION <code>path</code> <p>The file path to the FMU.</p> <p> TYPE: <code>str</code> </p> <code>description</code> <p>The model description of the FMU.</p> <p> </p> METHOD DESCRIPTION <code>__call__</code> <p>Creates and returns an FMU handler based on the FMI version.</p> <p>Initializes the FmuHandlerFactory with the given path and reads the model description.</p> PARAMETER DESCRIPTION <code>path</code> <p>The file path to the FMU.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>The appropriate FMU handler based on the FMI version.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the FMI version is not recognized.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def __init__(self, path: str):\n    \"\"\"\n    Initializes the FmuHandlerFactory with the given path and reads the model\n    description.\n\n    Args:\n        path (str): The file path to the FMU.\n\n    Returns:\n        The appropriate FMU handler based on the FMI version.\n\n    Raises:\n        ValueError: If the FMI version is not recognized.\n    \"\"\"\n    self.path = path\n    self.description = read_model_description(path)\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler","title":"FmuXHandler","text":"<pre><code>FmuXHandler(path, fmu_slave)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for handling FMU Slave objects (FMI 2.0 or FMI 3.0).</p> ATTRIBUTE DESCRIPTION <code>description</code> <p>The model description of the FMU.</p> <p> TYPE: <code>ModelDescription</code> </p> <code>var_name2attr</code> <p>A dictionary mapping variable names to their attributes.</p> <p> TYPE: <code>dict</code> </p> <code>fmu</code> <p>The FMU instance.</p> <p> TYPE: <code>FMU</code> </p> <code>output_var_names</code> <p>A list of output variable names.</p> <p> TYPE: <code>list</code> </p> METHOD DESCRIPTION <code>reset</code> <p>Abstract method to reset the FMU. Must be implemented by subclasses.</p> <code>step</code> <p>Abstract method to perform a simulation step. Must be implemented by     subclasses.</p> <code>cancel_step</code> <p>Cancels the current step of the FMU.</p> <code>get_state</code> <p>Retrieves the current state of the FMU.</p> <code>set_state</code> <p>Sets the state of the FMU to the given state.</p> <code>get_output_names</code> <p>Retrieves the names of the FMU output variables.</p> <code>get_input_names</code> <p>Retrieves the names of the FMU input variables.</p> <code>get_parameter_names</code> <p>Retrieves the names of the FMU tunable parameters.</p> <p>Initializes the FMU handler with the given path and FMU slave class.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path of .fmu file to open</p> <p> TYPE: <code>str</code> </p> <code>fmu_slave</code> <p>The FMU slave class of FMPy to use to open the fmu</p> <p> TYPE: <code>class</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def __init__(self, path: str, fmu_slave):\n    \"\"\"Initializes the FMU handler with the given path and FMU slave class.\n\n    Args:\n        path (str): The path of .fmu file to open\n        fmu_slave (class): The FMU slave class of FMPy to use to open the fmu\n    \"\"\"\n    # read the model description\n    self.description = read_model_description(path)\n\n    self.default_step_size = (\n        self.description.defaultExperiment.stepSize\n        if self.description.defaultExperiment\n        else None\n    )\n\n    # Create a dictionary to map variable names to attributes\n    self.var_name2attr = {}\n    for variable in self.description.modelVariables:\n        self.var_name2attr[variable.name] = variable\n\n    # extract the FMU and instantiate the slave\n    unzipdir = extract(path)\n    fmu_name = os.path.basename(path)\n\n    self.fmu = fmu_slave(\n        guid=self.description.guid,\n        unzipDirectory=unzipdir,\n        modelIdentifier=self.description.coSimulation.modelIdentifier,\n        instanceName=fmu_name,\n    )\n\n    # Get the output variable names\n    self.output_var_names = []\n    self.output_var_names = list(self.get_output_names())\n\n    # Instantiate the FMU\n    self.fmu.instantiate(loggingOn=False)\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.cancel_step","title":"cancel_step","text":"<pre><code>cancel_step()\n</code></pre> <p>Cancels the current step of the FMU.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def cancel_step(self):\n    \"\"\"Cancels the current step of the FMU.\"\"\"\n    self.fmu.cancelStep()\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_causality","title":"get_causality","text":"<pre><code>get_causality(name)\n</code></pre> <p>Retrieves the causality of a variable.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable to get</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The causality of the variable</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_causality(self, name: str) -&gt; str:\n    \"\"\"Retrieves the causality of a variable.\n\n    Args:\n        name (str): The name of the variable to get\n\n    Returns:\n        str: The causality of the variable\n    \"\"\"\n    return self.var_name2attr[name].causality\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_input_names","title":"get_input_names","text":"<pre><code>get_input_names()\n</code></pre> <p>Retrieves the list of names of the FMU's input variables.</p> RETURNS DESCRIPTION <code>list</code> <p>A list containing the name of each input variable</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_input_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the list of names of the FMU's input variables.\n\n    Returns:\n        list: A list containing the name of each input variable\n    \"\"\"\n    input_names = []\n    for variable in self.description.modelVariables:\n        if variable.causality == \"input\":\n            input_names.append(variable.name)\n    return input_names\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_output_names","title":"get_output_names","text":"<pre><code>get_output_names()\n</code></pre> <p>Retrieves the list of names of the FMU's output variables.</p> RETURNS DESCRIPTION <code>list</code> <p>A list containing the name of each output variable</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_output_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the list of names of the FMU's output variables.\n\n    Returns:\n        list: A list containing the name of each output variable\n    \"\"\"\n    output_names = []\n    for variable in self.description.modelVariables:\n        if variable.causality == \"output\":\n            output_names.append(variable.name)\n    return output_names\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_parameter_names","title":"get_parameter_names","text":"<pre><code>get_parameter_names()\n</code></pre> <p>Retrieves the names of the FMU tunable parameters. Returns:     list: A list containing the name of each tunable parameter</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_parameter_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the names of the FMU tunable parameters.\n    Returns:\n        list: A list containing the name of each tunable parameter\n    \"\"\"\n    parameter_names = []\n    for variable in self.description.modelVariables:\n        if variable.causality == \"parameter\":\n            parameter_names.append(variable.name)\n    return parameter_names\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_state","title":"get_state","text":"<pre><code>get_state()\n</code></pre> <p>Retrieves the current state of the FMU.</p> RETURNS DESCRIPTION <code>fmiXFMUState</code> <p>The current of state of the FMU, X is the version of FMI used (ie. fmi3FMUState for FMI3.0)</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_state(self):\n    \"\"\"Retrieves the current state of the FMU.\n\n    Returns:\n        fmiXFMUState: The current of state of the FMU, X is the version of FMI used\n            (ie. fmi3FMUState for FMI3.0)\n    \"\"\"\n    return self.fmu.getFMUstate()\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_variable","title":"get_variable","text":"<pre><code>get_variable(name)\n</code></pre> <p>Gets the variable matching the given name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable to get</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>The value of the variable</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_variable(self, name: str):\n    \"\"\"\n    Gets the variable matching the given name.\n\n    Args:\n        name (str): The name of the variable to get\n\n    Returns:\n        The value of the variable\n    \"\"\"\n    var = self.var_name2attr[name]\n    return getattr(self.fmu, f\"get{var.type}\")([var.valueReference])\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_variable_names","title":"get_variable_names","text":"<pre><code>get_variable_names()\n</code></pre> <p>Retrieves the names of all variables in the FMU.</p> RETURNS DESCRIPTION <code>list</code> <p>A list containing the name of each variable</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_variable_names(self) -&gt; list[str]:\n    \"\"\"Retrieves the names of all variables in the FMU.\n\n    Returns:\n        list: A list containing the name of each variable\n    \"\"\"\n    return [variable.name for variable in self.description.modelVariables]\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_variable_type","title":"get_variable_type","text":"<pre><code>get_variable_type(name)\n</code></pre> <p>Retrieves the type of the variable with the given name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the variable.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The type of the variable.</p> <p> TYPE: <code>str</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_variable_type(self, name: str) -&gt; str:\n    \"\"\"Retrieves the type of the variable with the given name.\n\n    Args:\n        name (str): The name of the variable.\n\n    Returns:\n        str: The type of the variable.\n    \"\"\"\n    return self.var_name2attr[name].type\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.get_variables","title":"get_variables","text":"<pre><code>get_variables(names)\n</code></pre> <p>Gets the values of the FMU variables matching the given names.</p> PARAMETER DESCRIPTION <code>names</code> <p>A list of variable names to get</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the variable names and their corresponding   values</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def get_variables(self, names: list[str]):\n    \"\"\"Gets the values of the FMU variables matching the given names.\n\n    Args:\n        names (list): A list of variable names to get\n\n    Returns:\n        dict: A dictionary containing the variable names and their corresponding\n              values\n    \"\"\"\n    return {name: self.get_variable(name) for name in names}\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.reset","title":"reset  <code>abstractmethod</code>","text":"<pre><code>reset()\n</code></pre> <p>Resets the FMU to its initial state and sets up the experiment.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>@abstractmethod\ndef reset(self):\n    \"\"\"Resets the FMU to its initial state and sets up the experiment.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.set_state","title":"set_state","text":"<pre><code>set_state(state)\n</code></pre> <p>Sets the state of the FMU to the given state.</p> PARAMETER DESCRIPTION <code>state</code> <p>The state of the FMU to set, X is the version of FMI used (ie. fmi3FMUState for FMI3.0)</p> <p> TYPE: <code>fmiXFMUState</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def set_state(self, state):\n    \"\"\"Sets the state of the FMU to the given state.\n\n    Args:\n        state (fmiXFMUState): The state of the FMU to set, X is the version of FMI\n            used (ie. fmi3FMUState for FMI3.0)\n    \"\"\"\n    self.fmu.setFMUstate(state)\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.set_variables","title":"set_variables","text":"<pre><code>set_variables(input_dict)\n</code></pre> <p>Sets the FMU variables to the given values.</p> PARAMETER DESCRIPTION <code>input_dict</code> <p>A dictionary containing variable names and their corresponding values.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>def set_variables(self, input_dict: dict):\n    \"\"\"Sets the FMU variables to the given values.\n\n    Args:\n        input_dict (dict): A dictionary containing variable names and their\n            corresponding values.\n    \"\"\"\n    for name, value in input_dict.items():\n        self._set_variable(name, value)\n</code></pre>"},{"location":"api/wrappers/#cofmpy.wrappers.FmuXHandler.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(current_time, step_size, input_dict)\n</code></pre> <p>Performs a simulation step with the given current time, step size, and input values.</p> Source code in <code>cofmpy/wrappers.py</code> <pre><code>@abstractmethod\ndef step(self, current_time, step_size, input_dict):\n    \"\"\"\n    Performs a simulation step with the given current time, step size, and input\n    values.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"generated/gallery/","title":"Examples","text":"<p>This section contains examples to illustrate the use of CoFMPy.</p> <p> A first example: an AC voltage source and a resistor </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:04.910 total execution time for generated_gallery files:</p> <p>+----------------------------------------------------------------------------------------+-----------+--------+ | plot_00_get_started (docs/examples/plot_00_get_started.py) | 00:04.910 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/gallery/plot_00_get_started/","title":"A first example: an AC voltage source and a resistor","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/plot_00_get_started/#a-first-example-an-ac-voltage-source-and-a-resistor","title":"A first example: an AC voltage source and a resistor","text":"<p>This is a simple example of how to use CoFMPy to load a co-simulation system (JSON configuration file and FMUs) and run the simulation.</p> <p>The use case is a simple system with an AC voltage source and a resistor. The AC voltage source generates a sinusoidal voltage signal, and the resistor consumes the power from the source. The resistor has a variable resistance that can be changed during the simulation.</p> <p>We will first download all necessary ressources such as FMUs (source and resistor) and the configuration file from the public link provided below.</p> <pre><code>import os\nimport urllib.request\nimport zipfile\n\nurl = \"https://share-is.pf.irt-saintexupery.com/s/39zaG9HkQWnePbi/download\"\n\n# Local path to ressources folder\nressources_path = \"example1.zip\"\n\n# Download and unzip the file\nurllib.request.urlretrieve(url, ressources_path)\nwith zipfile.ZipFile(ressources_path, \"r\") as zip_ref:\n    zip_ref.extractall(\".\")\n\n# Remove the zip file\nos.remove(ressources_path)\n\nprint(\"Ressources unzipped in example1 folder!\")\n</code></pre> <p>Out:</p> <pre><code>Ressources unzipped in example1 folder!\n</code></pre> <p>Now that we have all the necessary ressources, we can start the example.</p> <p>The base object in CoFMPy is the Coordinator. It manages all the components of CoFMPy: the Master algorithm, the graph engine, the data stream handlers, etc. In this tutorial, we only deal with the Coordinator that communicates for us.</p> <p>We will first import the Coordinator object from CoFMPy and create an instance of it.</p> <pre><code>from cofmpy import Coordinator\n\ncoordinator = Coordinator()\n</code></pre> <pre><code>Traceback (most recent call last):\n  File \"/home/cofri/dev/cofmpy-github/docs/examples/plot_00_get_started.py\", line 46, in &lt;module&gt;\n    from cofmpy import Coordinator\nModuleNotFoundError: No module named 'cofmpy'\n</code></pre>"},{"location":"generated/gallery/plot_00_get_started/#the-json-configuration-file","title":"The JSON configuration file","text":"<p>The first step is to create the JSON configuration file based on your system. This file must contain the information about the FMUs, the connections between them, and the simulation settings. For more information, check the page on how to create a JSON configuration file, see this page. The system also requires input data to run the simulation (here, the variable resistor from a CSV file).</p> <p>Here is the content of the configuration file for this example:</p> <pre><code>config_path = \"example1/config_with_csv.json\"\nwith open(config_path, \"r\") as f:\n    print(f.read())\n</code></pre> <p>In the JSON configuration file, you can see the following information:</p> <ul> <li>The 2 FMUs used in the system: an AC voltage source and a resistor</li> <li>2 connections:<ul> <li>the output of the source is connected to the input of the resistor</li> <li>the resistance value of the resistor is set by a CSV file</li> </ul> </li> <li>The simulation settings: the loop solver and the edge separator (used in the graph   visualization).</li> </ul> <p>The next step is to load the configuration file via the Coordinator. This will start the multiple components to handle the whole simulation process:</p> <ul> <li>the Master: the main process that controls the co-simulation</li> <li>the data stream handlers: the objects that read and write data from/to the system</li> <li>the graph engine</li> </ul> <pre><code>coordinator.start(config_path)\n</code></pre> <p>You can access the attributes of the components of the Coordinator object. For example, you can access the loop solver of the co-simulation via the <code>master.loop_solver</code> attribute.</p> <pre><code># We can check the list of FMUs in the Master or the loop solver used\nprint(\"FMUs in Master:\", list(coordinator.master.fmu_handlers.keys()))\nprint(f\"Loop solver: {coordinator.master.loop_solver}\")\n\n# ... and the stream handlers (here, the CSV source). Keys are (fmu_name, var_name)\nprint(\"\\nCSV data stream handler key:\", list(coordinator.stream_handlers.keys())[0])\n\ncsv_data_handler = coordinator.stream_handlers[(\"resistor\", \"R\")]\nprint(\"CSV path for resistance value R:\", csv_data_handler.path)\nprint(\"CSV data for R (as Pandas dataframe):\\n\", csv_data_handler.data.head())\n</code></pre>"},{"location":"generated/gallery/plot_00_get_started/#running-the-simulation","title":"Running the simulation","text":"<p>After loading the configuration file, you can run the simulation by calling the <code>do_step</code> method. This method will run the simulation for a given time step via the Master algorithm.</p> <p>The <code>do_step</code> method will save the results in the data storages defined in the configuration file. You can access the data storages using the <code>data_storages</code> attribute of the Coordinator object. By default, a data storage for all outputs is created in the \"storage/results.csv\" file (see below).</p> <pre><code>print(f\"Current time of the co-simulation: {coordinator.master.current_time}\")\n\ntime_step = 0.05\ncoordinator.do_step(time_step)\n\nprint(\n    \"Current time of the co-simulation after one step: \"\n    f\"{coordinator.master.current_time}\"\n)\n\n# Run N steps\nN = 30\nfor _ in range(N):\n    coordinator.do_step(time_step)\n\nprint(\n    f\"Current time of the co-simulation after {N+1} steps: \"\n    f\"{coordinator.master.current_time:.2f}\"\n)\n</code></pre> <p>It is possible to run the simulation until a specific end time by using the <code>run_simulation</code> method. This method will run the simulation until the end time and return the results of the simulation. TODO: Should we restart the simulation before running it? (init_simulation) or recreate the coordinator object?</p> <pre><code>end_time = 2.0\n\nresults = coordinator.run_simulation(time_step, end_time)\nprint(f\"Current time of the co-simulation: {coordinator.master.current_time:.2f}\")\n</code></pre>"},{"location":"generated/gallery/plot_00_get_started/#visualizing-the-results","title":"Visualizing the results","text":"<p>The simulation results are stored in the data storages. You can access the results via the <code>data_storages</code> attribute of the Coordinator object.</p> <pre><code>print(\"Data storages:\\n\", coordinator.data_storages)\n</code></pre> <p>You can visualize the results stored in the data storages.</p> <p>The default data storage is created for the results of the simulation: it stores the data for all outputs in a single CSV file. You can access the results via <code>coordinator.data_storages[\"results\"]</code>.</p> <pre><code>default_storage = coordinator.data_storages[\"results\"]\nresults = default_storage.load(\"results\")\nprint(results.head(10))\n</code></pre> <pre><code>results.plot(x=\"t\")\n</code></pre> <p>You can also visualize the graph of the system using the <code>plot_graph</code> method. This method will plot the connections between the FMUs in the system.</p> <pre><code>coordinator.graph_engine.plot_graph()\n</code></pre> <p>Total running time of the script: ( 0 minutes  4.910 seconds)</p> <p> Download Python source code: plot_00_get_started.py</p> <p> Download Jupyter notebook: plot_00_get_started.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"user_guide/configuration_file/","title":"Writing a JSON configuration file","text":"<p>This guide will help you write a JSON configuration file to define FMUs, their properties, the connections between FMUs and connections with external data.</p>"},{"location":"user_guide/configuration_file/#structure-of-the-configuration-file","title":"Structure of the configuration file","text":"<p>The configuration file consists of three main sections:</p> <ol> <li>FMUs (<code>fmus</code>): defines individual FMUs and their properties (id, path, step size,   supplier, etc.)</li> <li>Connections (<code>connections</code>): describes the connection graph.</li> <li>Global settings: specifies global configuration options.</li> </ol>"},{"location":"user_guide/configuration_file/#1-defining-fmus","title":"1. Defining FMUs","text":"<p>The <code>fmus</code> section contains the list of FMUs. Each FMU is represented by a dictionary with the following attributes:</p> <ul> <li><code>id</code>: a unique identifier for the FMU (e.g., \"FMU1\" or \"rotor\").</li> <li><code>path</code>: the file path of the FMU (see below).</li> <li><code>stepsize</code>: the step size for the FMU simulation (e.g., \"0.3 sec\").</li> <li><code>name</code> (optional): a human-readable name for the FMU (e.g., \"load\").</li> <li><code>initialization</code> (optional): key-value pairs to initialize variables in the FMU. An   initialization value could be overridden if a connection is defined for this variable.</li> <li><code>supplier</code> (optional): the supplier or creator of the FMU.</li> </ul> <p>Here is an example of an FMU description:</p> <pre><code>{\n    \"id\": \"load\",\n    \"path\": \"load.fmu\",\n    \"stepsize\": \"0.2 sec\",\n    \"name\": \"variable load\",\n    \"initialization\": {\"V_in\": 800, \"R\": 2.5},\n    \"supplier\": \"My company\"\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#paths-to-fmu-files","title":"Paths to FMU files","text":"<p>Paths to FMU files can be specified as:</p> <ol> <li>Relative paths. The configuration parser will search for files using <code>path</code> value, by considering the following:</li> <li>Files are placed at the same level than the configuration JSON file or in nested folders.</li> <li> <p>Each FMU file at the previously mentioned location has a unique name.</p> </li> <li> <p>Absolute paths. In this case, the <code>path</code> field will remain untouched and the FMUs will be loaded from the specified locations.</p> </li> </ol>"},{"location":"user_guide/configuration_file/#2-defining-connections","title":"2. Defining Connections","text":"<p>The <code>connections</code> section is a list of connections. A connection links a source to a target. The generic JSON structure for a connection is:</p> <pre><code>{\n    \"source\": {...},\n    \"target\": {...}\n}\n</code></pre> <p>Three types of connections can be defined in the JSON file:</p> <ul> <li>a connection between two FMUS</li> <li>a connection from a data source to an FMU</li> <li>a connection from an FMU to a data \"sink\"</li> </ul> <p>Each connection type is described in the following subsections.</p>"},{"location":"user_guide/configuration_file/#between-two-fmus","title":"Between two FMUs","text":"<p>A connection between two FMUs represents the interaction between the subsystems in the co-simulation. The connection links the output variable of an FMU to the input variable of another FMU. A source/target for an FMU is defined with:</p> <ul> <li><code>id</code>: the FMU id as defined in the <code>fmus</code> section.</li> <li><code>variable</code>: the variable name in the FMU</li> <li><code>unit</code>: (optional) the unit of the variable</li> </ul>"},{"location":"user_guide/configuration_file/#example","title":"Example","text":"<p>For a connection from variable <code>I_out</code> of FMU <code>battery</code> to variable <code>Iload_in</code> of FMU <code>load</code>, the JSON description is:</p> <pre><code>{\n    \"source\": {\"id\": \"battery\", \"variable\": \"I1_out\", \"unit\": \"A\"},\n    \"target\": {\"id\": \"load\", \"variable\": \"Iload_in\"}\n}\n</code></pre> <p>Note</p> <p>A connection source/target has a <code>type</code> which is <code>fmu</code> by default. It is possible to add this field to be more explicit in the JSON: <code>\"type\": \"fmu\"</code>.</p>"},{"location":"user_guide/configuration_file/#from-a-data-source-to-an-fmu","title":"From a data source to an FMU","text":"<p>A connection from an external data source to an FMU is required when one input variable of a FMU is controlled by external data. The data source will be used as input values for the FMU. In CoFMPy, we provide multiple external data sources: from single values, from a CSV file, or from a Kafka stream. You can also create your own data source (see documentation).</p> <p>The information required varies depending on the data source. For each type of source, a field <code>type</code> is required. Note that for all types, the field <code>unit</code> is optional.</p>"},{"location":"user_guide/configuration_file/#from-single-values-literal","title":"From single values (literal)","text":"<ul> <li><code>type</code>: <code>literal</code></li> <li><code>values</code>: a key-value dictionary  with the values of the variable at   different timestamps, e.g. <code>{\"0.1\": 12.2, \"0.5\": 8.6}</code>. Note that keys in JSON must   be strings, timestamps \"0.1\" and \"0.5\" above are then represented as strings. <li><code>interpolation</code>: (optional) interpolation method (see interpolation reference). Defaults to <code>previous</code>.</li>"},{"location":"user_guide/configuration_file/#example_1","title":"Example","text":"<p>The variable <code>R</code>\u00a0of a FMU <code>resistor</code> is defined as \"literal\". The corresponding JSON description is:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"literal\", \n        \"values\": {\"0\": 100, \"12.5\": 250}, \n        \"interpolation\": \"linear\"\n    },\n    \"target\": {\"id\": \"resistor\", \"variable\": \"R\", \"unit\": \"Ohm\"}\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#from-a-csv-file","title":"From a CSV file","text":"<ul> <li><code>type</code>: <code>csv</code></li> <li><code>path</code>: the path to the CSV file</li> <li><code>variable</code>: the variable name to read in the CSV. It must correspond to the column   header name.</li> <li><code>interpolation</code>: (optional) interpolation method (see interpolation reference). Defaults to <code>previous</code>.</li> </ul> <p>If you want to know how CSV files must be formatted to be correctly read by CoFMPy, refer to the section on CSV data source.</p>"},{"location":"user_guide/configuration_file/#example_2","title":"Example","text":"<p>The variable <code>V</code> of FMU <code>battery</code> is controlled according to the values in the CSV file <code>path/to/battery_data.csv</code> (column called <code>voltage</code>). The interpolation is set to <code>previous</code>. The corresponding JSON connection is:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"csv\",\n        \"path\": \"path/to/battery_data.csv\",\n        \"variable\": \"voltage\",\n        \"unit\": \"V\",\n        \"interpolation\": \"previous\"\n    },\n    \"target\": {\"id\": \"battery\", \"variable\": \"V\", \"unit\": \"V\"}\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#from-a-kafka-stream","title":"From a Kafka stream","text":"<ul> <li><code>type</code>: <code>kafka</code></li> <li><code>uri</code>: the server URL (with port), e.g. <code>127.0.0.1:9092</code></li> <li><code>group_id</code>: the consumer group id.</li> <li><code>topic</code>: the topic to listen to.</li> <li><code>variable</code>: the variable name to read in the Kafka topic. It must correspond to the   variable name used in the Kafka message.</li> <li><code>interpolation</code>: (optional) interpolation method (see interpolation reference). Defaults to <code>previous</code>.</li> <li><code>timeout</code>: (optional) delay, in seconds, to wait (blocking) after reception of the first message before proceeding with the rest of the cosimulation. Defaults to <code>2</code>.</li> </ul> <p>If you want to know how Kafka messages must be formatted to be correctly read by CoFMPy, refer to the section on Kafka data source.</p>"},{"location":"user_guide/configuration_file/#example_3","title":"Example","text":"<p>The variable <code>V</code> of FMU <code>battery</code> is controlled by the values from a Kafka server. A single message is formatted as follows: <code>{\"t\":, \"\":, \"\":, \"\":, }</code>. The corresponding JSON connection is:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"kafka\",\n        \"uri\": \"172.17.0.1:5000\",\n        \"group_id\": \"my_group\",\n        \"topic\": \"cofmpy_topic\",\n        \"variable\": \"voltage\",\n        \"interpolation\": \"linear\",\n        \"timeout\": 1,\n\n    },\n    \"target\": {\"id\": \"battery\", \"variable\": \"V\", \"unit\": \"V\"}\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#from-an-fmu-to-a-data-sink","title":"From an FMU to a data sink","text":"<p>A connection from an FMU to a data \"sink\" represents a connection towards the \"outside\". A sink can be a data storage system (e.g. a file or database system) or an outbound data stream (e.g. a Kafka data stream). The JSON description is equivalent to the previous cases.</p> <p>By default, CoFMPy will save all output variables of the co-simulation in a single CSV file for each simulation step. The location of this file is <code>storage/results.csv</code>.</p>"},{"location":"user_guide/configuration_file/#to-a-csv-file","title":"To a CSV file","text":"<ul> <li><code>type</code>: <code>csv</code></li> <li><code>output_dir</code>: the directory where the CSV file will be created.</li> <li><code>variable</code>: the name of the variable, used as the CSV filename and the header column   name in the CSV file.</li> <li><code>overwrite</code>: (optional) overwrite an existing file if <code>true</code>. Defaults to <code>true</code>.</li> <li><code>unit</code>: (optional) the unit of the variable.</li> </ul>"},{"location":"user_guide/configuration_file/#example_4","title":"Example","text":"<pre><code>{\n    \"source\": {\"id\": \"FMU1\", \"variable\": \"V_out\", \"unit\": \"V\"},\n    \"target\": {\n        \"type\": \"csv\",\n        \"id\": \"csv_out_V\",\n        \"output_dir\": \"path/to/folder/\",\n        \"variable\": \"FMU1.V\",\n        \"overwrite\": true\n    }\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#to-a-kafka-stream","title":"To a Kafka stream","text":"<ul> <li><code>id</code>: an ID to name the connection</li> <li><code>uri</code>: the Kafka server URL (with the port number)</li> <li><code>variable</code>: the name of the variable, used to send messages on the Kafka topic.</li> <li><code>group_id</code>: the consumer group id.</li> <li><code>topic</code>: the topic to listen to.</li> <li><code>unit</code>: (optional) the unit of the variable.</li> </ul>"},{"location":"user_guide/configuration_file/#example_5","title":"Example","text":"<p>A JSON example for Kafka data stream:</p> <pre><code>{\n    \"source\": {\"id\": \"FMU2\", \"variable\": \"I_out\", \"unit\": \"A\"},\n    \"target\": {\n        \"type\": \"kafka\",\n        \"id\": \"kafka_out_1\",\n        \"uri\": \"172.17.0.1:5050\",\n        \"variable\": \"FMU2.I\",\n        \"config\": {\"group_id\": \"my_group\", \"topic\": \"FMU2.I\"},\n        \"unit\": \"A\"\n    }\n}\n</code></pre>"},{"location":"user_guide/configuration_file/#3-global-settings","title":"3. Global settings","text":"<p>Besides the description of the FMUs and the connections, the JSON configuration file also specifies global settings used by CoFMPy.</p> <ul> <li><code>loop_method</code>: specifies the algorithm for solving system loops (e.g., <code>jacobi</code>,   <code>gauss-seidel</code>).</li> <li><code>edge_sep</code>: defines the separator for connection naming. Default is <code>-&gt;</code>.</li> <li><code>root</code>: specifies the root directory for relative paths.</li> </ul>"},{"location":"user_guide/configuration_file/#tips-for-writing-a-configuration-file","title":"Tips for writing a configuration file","text":"<ul> <li>Use unique IDs: ensure all FMUs and data sources have unique IDs.</li> <li>Verify paths: check that all path attributes are valid and accessible.</li> <li>Specify units: use consistent units across all variables to avoid mismatches.</li> <li>Test connections: verify connections are logical and complete.</li> <li>Validate JSON: Use a JSON validator to ensure the configuration file is error-free.</li> </ul> <p>This guide should help users create and manage their JSON configuration files effectively. A full JSON example is provided in the \"Examples\" section.</p>"},{"location":"user_guide/configuration_file/#interpolation-reference","title":"Interpolation reference","text":"<p>Interpolation is used when the system needs a value between two time points when data external to FMUs is used (literal, csv, kafka, etc.). </p> <p>The interpolation uses <code>cofmpy.utils.Interpolator</code> class which supports a wide variety of interpolation methods. The currently tested methods are: - <code>previous</code>, which returns the value at the previous time point (default value) - <code>linear</code>, which calculates a linearly interpolated value between the previous and   next points.</p> <p>The other methods will log the following warning: <code>Method '{method}' is in beta version. We recommend using 'linear' or 'previous'</code></p> <p>For more details, please refer to: <code>./notebooks/interpolator.ipynb</code></p>"},{"location":"user_guide/cosimulation_initialization/","title":"Fixed-Point Initialization in CoFMPy","text":""},{"location":"user_guide/cosimulation_initialization/#understanding-fixed-point-initialization","title":"Understanding Fixed-Point Initialization","text":"<p>In a co-simulation involving multiple FMUs, the user-defined initial state \\(x_0\\) represents the starting values for all system variables. However, if \\(x_0\\) is not dynamically consistent, meaning it does not satisfy the physical constraints of the system, the simulation may start from an unrealistic state, leading to numerical instabilities or incorrect results.</p> <p>To correct this, CoFMPy provides a fixed-point initialization process that finds a valid initial state \\(x_0^*\\) close to \\(x_0\\), such that:</p> \\[ f(x_0^*) = x_0^* \\] <p>where \\(f\\) is the numerical time integrator, responsible for advancing the system\u2019s state to the next time step (basically built on <code>do_step</code>). This ensures that \\(x_0^*\\) is a fixed-point solution, meaning the system starts in a physically valid configuration.</p>"},{"location":"user_guide/cosimulation_initialization/#enabling-fixed-point-initialization-in-cofmpy","title":"Enabling Fixed-Point Initialization in CoFMPy","text":"<p>To ensure a dynamically valid initialization, you can enable the fixed-point initialization by setting <code>fixed_point_init=True</code> when starting the simulation coordinator:</p> <pre><code>coordinator.start(config_path, fixed_point_init=True)\n</code></pre> <p>When <code>fixed_point_init=False</code>, CoFMPy will use the user-provided or default initial values without verifying their validity. This may be faster, but it can lead to inconsistencies in coupled FMUs, which may cause instability or incorrect results.</p> <p>When <code>fixed_point_init=True</code>, CoFMPy internally:</p> <ol> <li>Constructs an optimization function that represents the co-simulation architecture.</li> <li>Solves for a valid initial state \\(x_0^\u2217\\) using a numerical solver, ensuring consistency across all FMUs.</li> <li>Uses <code>fsolve</code> from SciPy by default to find a solution, using:<ul> <li>The minimum of default integration time steps defined in each FMU\u2019s XML metadata.</li> <li>Default solver parameters.</li> </ul> </li> </ol>"},{"location":"user_guide/cosimulation_initialization/#customizing-the-fixed-point-solver","title":"Customizing the Fixed-Point Solver","text":"<p>By default, CoFMPy uses SciPy's <code>fsolve</code> with its default arguments. However, you can customize:</p> <ul> <li>The solver method (<code>fsolve</code> or other supported solvers).</li> <li>The fixed-point iteration step size (<code>time_step</code>).</li> <li>The solver\u2019s argument passed as keyword arguments dictionnary</li> </ul> <p>To modify these settings, pass the desired options using <code>fixed_point_kwargs</code>:</p> <pre><code> # Customize fixed point solver\n fixed_point_kwargs = {\n      \"solver\": \"fsolve\",\n      \"time_step\": 5e-8,\n      \"tolerance\": 1e-5,\n      \"max_iterations\": 100,\n  }\n\n  coordinator.start(config_path, fixed_point_init=True, fixed_point_kwargs=fixed_point_kwargs)  \n</code></pre>"},{"location":"user_guide/cosimulation_initialization/#supported-solvers","title":"Supported Solvers","text":"<p>Currently, CoFMPy supports the following solver:</p> <ul> <li><code>scipy.optimize.fsolve</code><ul> <li>Used for finding roots of nonlinear equations via a hybrid Powell method.</li> <li>Automatically approximates the Jacobian if not provided.</li> <li>For more details, refer to the SciPy documentation:\ud83d\udc49 fsolve \u2014 SciPy v1.15.1 Manual</li> </ul> </li> </ul> <p>Support for additional solvers is planned in future versions.</p>"},{"location":"user_guide/data_sources/","title":"Managing data sources","text":"<p>External data can be useful to control variable parameters, to use as input from an other system simulation or just to get from measurements from a physical twin. CoFMPy provides multiple data source handlers detailed below.</p> <p>Whatever the data source, the connection between the data source and the target variable of the simulation is defined in the JSON configuration file as a connection:</p> <pre><code>\"connections\":\u00a0[\n    {\n        \"source\": {...},\n        \"target\": {\"id\": \"fmu_target\", \"variable\": \"my_variable\", \"unit\": \"my_unit\"}\n    },\n    {\n        ...\n    }\n]\n</code></pre>"},{"location":"user_guide/data_sources/#single-values-the-simplest-approach","title":"Single values, the simplest approach","text":"<p>If your variable is fixed or only changes a few times, this is the simplest way to define the values. This is done directly in the JSON configuration file. The expected format is a dictionary with times and values. For example <code>{\"0\": 1.0, \"0.5\": 2.8}</code> corresponds to a variable that takes value 1.0 at the beginning of the simulation (t=0) and have a single change at t=0.5 with the value 2.8. You can have either zero changes (i.e. a fixed value for the whole simulation) or any changes you want.</p> <p>The JSON configuration file must follow the syntax below:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"local\",\n        \"values\": {\"0\": 0, \"0.1\": 12.2, \"0.5\": 8.6},\n        \"unit\": \"A\"\n    },\n    \"target\": {\"id\": \"FMU2\", \"variable\": \"Iload_in\", \"unit\": \"A\"}\n}\n</code></pre> <p>In case the variable has many changes, we suggest to use the second method, a CSV file.</p>"},{"location":"user_guide/data_sources/#a-csv-file","title":"A CSV file","text":"<p>Data can be read directly from a CSV file. It must contain a first column with the time instants, and other following columns with the values for one or several variables. A file must start with a header containing the names of the columns: <code>t</code> for the first column and the variable names for others, e.g. <code>t,R,V_out,Iload</code>.</p> <p>Here is an example of data source CSV file:</p> <pre><code>t,R,V_out,Iload\n0,100,5,0\n0.1,100,5,0.8\n0.5,100,10,0.8\n0.7,200,5,2.5\n</code></pre> <p>To connect CSV data to an FMU variable in CoFMPy, the connection is described in the JSON configuration file as follows:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"csv\",\n        \"path\": \"path/to/the/file.csv\",\n        \"variable\": \"R\",\n        \"interpolation\": \"previous\",\n        \"unit\": \"Ohm\"\n    },\n    \"target\": {\"id\": \"resistor\", \"variable\": \"R\", \"unit\": \"Ohm\"}\n}\n</code></pre> <p>Note that a parameter can be defined when configuring the CSV source handler:</p> <ul> <li><code>interpolation</code>: specifies the type of interpolation used when the system needs a   value between two time points in the CSV file. It can be set to <code>previous</code>, which   returns the previous value, or <code>linear</code>, which calculates a linearly interpolated   value between the previous and next points. For example in the CSV file above, if   <code>R</code> must be retrieved at t=0.65, if <code>interpolation=\"previous\"</code> the data handler will   return 100, being the previous value at t=0.5. If <code>interpolation=\"linear\"</code> the data   handler will return 175, being the linear interpolation between t=0.5 (R=100) and   t=0.7 (R=200).</li> </ul>"},{"location":"user_guide/data_sources/#a-kafka-stream","title":"A Kafka stream","text":"<p>The last data source proposed in CoFMPy is a Kafka broker. Data is retrieved from a Kafka topic in a specific format: a message must contain the time instants and their corresponding values. For example, a message with three values must be formatted as a list of tuples:</p> <pre><code>[\n    (0, 100),\n    (0.1, 200),\n    (1.3, 52)\n]\n</code></pre> <p>TODO: a topic per variable? Or a common topic and variables are received in the message?</p> <p>To connect the Kafka topic to a FMU variable, the connection is described in the JSON configuration file as follows:</p> <pre><code>{\n    \"source\": {\n        \"type\": \"kafka\",\n        \"uri\": \"localhost:5000\",\n        \"group_id\": \"my_group\",\n        \"topic\": \"V_in\",\n        \"variable\": \"V_in\",\n        \"unit\": \"V\"\n    },\n    \"target\": {\"id\": \"voltage_source\", \"variable\": \"V_in\", \"unit\": \"V\"}\n}\n</code></pre> <p>Some parameters of the Kafka stream must be set:</p> <ul> <li><code>uri</code>: the address of the Kafka server (with port information)</li> <li><code>group_id</code>: the consumer group id</li> <li><code>topic</code>: the topic to listen to</li> </ul>"},{"location":"user_guide/data_sources/#custom-data-sources","title":"Custom data sources","text":"<p>For advanced users, it is possible to create your own custom data stream handler that feeds FMUs with external data. See page Create your own data stream handler.</p>"},{"location":"user_guide/helpers/","title":"\ud83d\udee0\ufe0f CoFMPy Helper Scripts","text":"<p>CoFMPy provides a set of helper scripts designed to simplify working with Functional Mock-up Units (FMUs) and co-simulation workflows. These scripts offer debugging tools, model extraction utilities, and automation features to enhance user experience.</p>"},{"location":"user_guide/helpers/#available-helper-scripts","title":"\ud83d\udcdc Available Helper Scripts","text":"Script Name Description <code>extract_fmu</code> Extracts and displays all metadata from an FMU file. <code>User Interface</code> \ud83d\udea7 Coming soon..."},{"location":"user_guide/helpers/#extracting-fmu-information-with-extract_fmu","title":"\ud83d\udce6 Extracting FMU Information with <code>extract_fmu</code>","text":"<p>The <code>extract_fmu</code> helper script is a command-line tool designed to extract and display all relevant information from an FMU (Functional Mock-up Unit) file. It helps users quickly inspect FMU metadata, including:</p> <ul> <li>Inputs, outputs, and parameters</li> <li>Integration step size</li> <li>Default values and variable types</li> </ul> <p>This tool is particularly useful for debugging, documentation, and ensuring FMU compatibility before running co-simulations.</p>"},{"location":"user_guide/helpers/#usage","title":"\ud83d\udcdc Usage","text":"<p>The extract_fmu script is executed from the command line with the following syntax:</p> <pre><code>python extract_fmu.py &lt;path_to_fmu_file&gt;\n</code></pre> <p>For example, if you have an FMU file named <code>model.fmu</code> in the current directory, run:</p> <pre><code>python extract_fmu.py model.fmu\n</code></pre> <p>This will extract and display all the FMU metadata in a well-structured table.</p>"},{"location":"user_guide/advanced/custom_stream_handler/","title":"Create your own data stream handler","text":"<p>WORK IN PROGRESS</p>"}]}